game.StarterGui:SetCore("SendNotification",{
    Title = "Message from ImaMeow";
    Text = "Please know this script is discontinued and now opensource"
  })
task.wait(2)

local Arrayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/UI-Interface/CustomFIeld/main/RayField.lua"))()

local function fuckdoll()
     local togglebackshot = false
	game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-gh 90960046381276 140395948277978 138364679836274 97239052720959 17401151565 17387616772 MeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeowMeow")
	wait(1)
	game.Players.LocalPlayer.Character["Accessory (RARM)"].Handle:BreakJoints()
	game.Players.LocalPlayer.Character["Accessory (Black)"].Handle:BreakJoints()
	game.Players.LocalPlayer.Character["Accessory (Christmas Santa Hat Curly Girl Hair (Brown))"].Handle:BreakJoints()
	game.Players.LocalPlayer.Character["Accessory (LARM)"].Handle:BreakJoints()
	game.Players.LocalPlayer.Character["Accessory (rightleg)"].Handle:BreakJoints()
	game.Players.LocalPlayer.Character["Accessory (LLeg)"].Handle:BreakJoints()
	spawn(function()
		while true do
			game.Players.LocalPlayer.Character["Accessory (RARM)"].Handle.Velocity = Vector3.new(0,50,0)
			game.Players.LocalPlayer.Character["Accessory (Black)"].Handle.Velocity = Vector3.new(0,50,0)
			game.Players.LocalPlayer.Character["Accessory (Christmas Santa Hat Curly Girl Hair (Brown))"].Handle.Velocity = Vector3.new(0,50,0)
			game.Players.LocalPlayer.Character["Accessory (LARM)"].Handle.Velocity = Vector3.new(0,50,0)
			game.Players.LocalPlayer.Character["Accessory (rightleg)"].Handle.Velocity = Vector3.new(0,50,0)
			game.Players.LocalPlayer.Character["Accessory (LLeg)"].Handle.Velocity = Vector3.new(0,50,0)
			task.wait()
		end
	end)
	local attach0 = Instance.new("Attachment")
	local attach1 = Instance.new("Attachment")
	attach1.Name = "Right Arm"
	local attach02 = Instance.new("Attachment")
	local attach12 = Instance.new("Attachment")
	attach12.Name = "Torso"
	local attach03 = Instance.new("Attachment")
	local attach13 = Instance.new("Attachment")
	attach13.Name = "Hair"
	local attach04 = Instance.new("Attachment")
	local attach14 = Instance.new("Attachment")
	attach14.Name = "Left Arm"
	local attach05 = Instance.new("Attachment")
	local attach15 = Instance.new("Attachment")
	attach15.Name = "Right Leg"
	local attach06 = Instance.new("Attachment")
	local attach16 = Instance.new("Attachment")
	attach16.Name = "Left Leg"
	local alignmove = Instance.new("AlignPosition")
	local alignrotate = Instance.new("AlignOrientation")
	local alignmove2 = Instance.new("AlignPosition")
	local alignrotate2 = Instance.new("AlignOrientation")
	local alignmove3 = Instance.new("AlignPosition")
	local alignrotate3 = Instance.new("AlignOrientation")
	local alignmove4 = Instance.new("AlignPosition")
	local alignrotate4 = Instance.new("AlignOrientation")
	local alignmove5 = Instance.new("AlignPosition")
	local alignrotate5 = Instance.new("AlignOrientation")
	local alignmove6 = Instance.new("AlignPosition")
	local alignrotate6 = Instance.new("AlignOrientation")
	attach0.Parent = game.Players.LocalPlayer.Character["Accessory (RARM)"].Handle
	attach1.Parent = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	attach1.Position = Vector3.new(-5.606,0,0)
	attach1.Orientation = Vector3.new(-0,0,-90)
	alignmove.Parent = attach0.Parent
	alignmove.MaxForce = math.huge
	alignmove.Responsiveness = math.huge
	alignmove.Attachment0 = attach0
	alignmove.Attachment1 = attach1
	alignrotate.Parent = attach0.Parent
	alignrotate.MaxTorque = math.huge
	alignrotate.Responsiveness = math.huge
	alignrotate.Attachment0 = attach0
	alignrotate.Attachment1 = attach1
	attach02.Parent = game.Players.LocalPlayer.Character["Accessory (Black)"].Handle
	attach12.Parent = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	attach12.Position = Vector3.new(-4.199,0,0)
	alignmove2.Parent = attach02.Parent
	alignmove2.MaxForce = math.huge
	alignmove2.Responsiveness = math.huge
	alignmove2.Attachment0 = attach02
	alignmove2.Attachment1 = attach12
	alignrotate2.Parent = attach02.Parent
	alignrotate2.MaxTorque = math.huge
	alignrotate2.Responsiveness = math.huge
	alignrotate2.Attachment0 = attach02
	alignrotate2.Attachment1 = attach12
	attach03.Parent = game.Players.LocalPlayer.Character["Accessory (Christmas Santa Hat Curly Girl Hair (Brown))"].Handle
	attach13.Parent = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	attach13.Position = Vector3.new(-4.183,0.952,0)
	alignmove3.Parent = attach03.Parent
	alignmove3.MaxForce = math.huge
	alignmove3.Responsiveness = math.huge
	alignmove3.Attachment0 = attach03
	alignmove3.Attachment1 = attach13
	alignrotate3.Parent = attach03.Parent
	alignrotate3.MaxTorque = math.huge
	alignrotate3.Responsiveness = math.huge
	alignrotate3.Attachment0 = attach03
	alignrotate3.Attachment1 = attach13
	attach04.Parent = game.Players.LocalPlayer.Character["Accessory (LARM)"].Handle
	attach14.Parent = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	attach14.Position = Vector3.new(-2.752,-0,0)
	attach14.Orientation = Vector3.new(0,0,-90)
	alignmove4.Parent = attach04.Parent
	alignmove4.MaxForce = math.huge
	alignmove4.Responsiveness = math.huge
	alignmove4.Attachment0 = attach04
	alignmove4.Attachment1 = attach14
	alignrotate4.Parent = attach04.Parent
	alignrotate4.MaxTorque = math.huge
	alignrotate4.Responsiveness = math.huge
	alignrotate4.Attachment0 = attach04
	alignrotate4.Attachment1 = attach14
	attach05.Parent = game.Players.LocalPlayer.Character["Accessory (rightleg)"].Handle
	attach15.Parent = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	attach15.Position = Vector3.new(-4.665,-1.904,0)
	attach15.Orientation = Vector3.new(0,0,-90)
	alignmove5.Parent = attach05.Parent
	alignmove5.MaxForce = math.huge
	alignmove5.Responsiveness = math.huge
	alignmove5.Attachment0 = attach05
	alignmove5.Attachment1 = attach15
	alignrotate5.Parent = attach05.Parent
	alignrotate5.MaxTorque = math.huge
	alignrotate5.Responsiveness = math.huge
	alignrotate5.Attachment0 = attach05
	alignrotate5.Attachment1 = attach15
	attach06.Parent = game.Players.LocalPlayer.Character["Accessory (LLeg)"].Handle
	attach16.Parent = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	attach16.Position = Vector3.new(-3.73,-1.912,0)
	attach16.Orientation = Vector3.new(0,0,-90)
	alignmove6.Parent = attach06.Parent
	alignmove6.MaxForce = math.huge
	alignmove6.Responsiveness = math.huge
	alignmove6.Attachment0 = attach06
	alignmove6.Attachment1 = attach16
	alignrotate6.Parent = attach06.Parent
	alignrotate6.MaxTorque = math.huge
	alignrotate6.Responsiveness = math.huge
	alignrotate6.Attachment0 = attach06
	alignrotate6.Attachment1 = attach16
	game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(bind)
		if bind == "z" then
			attach1.Position = Vector3.new(-5.606,0,0)
			attach1.Orientation = Vector3.new(-0,0,-90)
			attach12.Position = Vector3.new(-4.199,0,0)
			attach12.Orientation = Vector3.new(0,0,0)
			attach13.Position = Vector3.new(-4.183,0.952,0)
			attach13.Orientation = Vector3.new(0,0,0)
			attach14.Position = Vector3.new(-2.752,-0,0)
			attach14.Orientation = Vector3.new(0,0,-90)
			attach15.Position = Vector3.new(-4.665,-1.904,0)
			attach15.Orientation = Vector3.new(0,0,-90)
			attach16.Position = Vector3.new(-3.73,-1.912,0)
			attach16.Orientation = Vector3.new(0,0,-90)
		end
	end)
	game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(bind)
		if bind == "x" then
			if togglebackshot == false then
				attach1.Position = Vector3.new(1.546,-0.124,-1.096)
				attach1.Orientation = Vector3.new(-75,180,90)
				attach12.Position = Vector3.new(-0.072,-0.596,-1.355)
				attach12.Orientation = Vector3.new(-45,-0,-0)
				attach13.Position = Vector3.new(-0.065,0.282,-1.989)
				attach13.Orientation = Vector3.new(-30,0,-0)
				attach14.Position = Vector3.new(-1.522,-0.07,-1.039)
				attach14.Orientation = Vector3.new(-75,180,90)
				attach15.Position = Vector3.new(0.493,-1.904,-1.037)
				attach15.Orientation = Vector3.new(0,0,-90)
				attach16.Position = Vector3.new(-0.518,-1.912,-1.037)
				attach16.Orientation = Vector3.new(0,0,-90)
				togglebackshot = true
			else
				attach1.Position = Vector3.new(1.546,-0.487,-1.518)
				attach1.Orientation = Vector3.new(-75,180,90)
				attach12.Position = Vector3.new(-0.072,-0.531,-1.664)
				attach12.Orientation = Vector3.new(-75,0,-0)
				attach13.Position = Vector3.new(-0.065,-0.088,-2.653)
				attach13.Orientation = Vector3.new(-60,0,-0)
				attach14.Position = Vector3.new(-1.522,-0.433,-1.46)
				attach14.Orientation = Vector3.new(-75,180,90)
				attach15.Position = Vector3.new(0.493,-1.904,-1.037)
				attach15.Orientation = Vector3.new(0,0,-90)
				attach16.Position = Vector3.new(-0.518,-1.912,-1.037)
				attach16.Orientation = Vector3.new(0,0,-90)
				togglebackshot = false
			end
		end
	end)
end

local function meowz()
	local rightarm = {"RARM";"International Fedora"}
local leftarm = {"LARM";"Robloxclassicred"}
local rightleg = {"MeshPartAccessory";"RCap"}
local leftleg = {"Unloaded head";"RunningBull"}
local torso = {"Black";"MediHood";"Accessory (White Torso)"}
game.Players.LocalPlayer.Character.Archivable = true
local fakechar = game.Players.LocalPlayer.Character:Clone()
fakechar.Parent = game.Workspace
for i,v in pairs(fakechar:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end
fakechar.Head.face.Transparency = 1
game.Players.LocalPlayer.Character.Parent = fakechar
local realchar = fakechar[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
fakechar.Animate.Disabled = true
fakechar.Animate.Enabled = true
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		task.wait()
	end
end)
game.Players.LocalPlayer.CharacterAdded:Connect(function()
task.wait(.1)
game.Players.LocalPlayer.Character.Parent = fakechar
realchar = fakechar[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		task.wait()
	end
end)
end)
game.Players.LocalPlayer.SimulationRadius = 9999
end

local function animationmeowz()
	local rightarm = {"RARM";"International Fedora"}
local leftarm = {"LARM";"Robloxclassicred"}
local rightleg = {"MeshPartAccessory";"RCap"}
local leftleg = {"Unloaded head";"RunningBull"}
local torso = {"Black";"MediHood";"Accessory (White Torso)"}
game.Players.LocalPlayer.Character.Archivable = true
local fakechar = game.Players.LocalPlayer.Character:Clone()
fakechar.Parent = game.Workspace
for i,v in pairs(fakechar:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end
fakechar.Head.face.Transparency = 1
game.Players.LocalPlayer.Character.Parent = fakechar
local realchar = fakechar[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
fakechar.Animate.Disabled = true
fakechar.Animate.Enabled = true
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		task.wait()
	end
end)
game.Players.LocalPlayer.CharacterAdded:Connect(function()
task.wait(.1)
game.Players.LocalPlayer.Character.Parent = fakechar
realchar = fakechar[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		task.wait()
	end
end)
end)
game.Players.LocalPlayer.SimulationRadius = 9999
local cmt = {
	Angles = function(x,y,z,useRad)
		if not useRad then
			return CFrame.Angles(x,y,z)
		else
			return CFrame.Angles(math.rad(x),math.rad(y),math.rad(z))
		end
	end
}
local imt = {
	CreateWeld = function(p1,p2,c0,c1)
		c0,c1 = c0 or CFrame.new(0,0,0),c1 or CFrame.new(0,0,0)
		local weld = Instance.new("Motor6D",p1)
		weld.Part0,weld.Part1 = p1,p2
		weld.C0,weld.C1 = c0,c1
		return weld
	end,
	New = function(type,args)
		local instance = Instance.new(type)
		for i,v in pairs(args) do
			pcall(function()
				instance[i] = v
			end)
		end
		return instance
	end,
	Remove = function(instance,time)
		time = time or 0
		game:GetService("Debris"):AddItem(instance,time)
	end
}
local math     = setmetatable({random = function(minNum,maxNum,div) div = div or 1 return math.random(minNum * div,maxNum * div)/div end},{__index = math})
local CFrame   = setmetatable(cmt,{__index = CFrame})
local Instance = setmetatable(imt,{__index = Instance})

local stepped = game:GetService("RunService").Stepped

--BasicFunctions
local ins    = Instance.new
local v3     = Vector3.new
local cf     = CFrame.new
local angles = CFrame.Angles
local rad    = math.rad
local huge   = math.huge
local cos    = math.cos
local sin    = math.sin
local tan    = math.tan
local ray    = Ray.new
local random = math.random
local ud     = UDim.new
local ud2    = UDim2.new
local c3     = Color3.new
local rgb    = Color3.fromRGB
local bc     = BrickColor.new

--Variables
local uis = game:GetService("UserInputService")
local plr	 = game.Players.LocalPlayer
local plrg   = plr.PlayerGui
local char   = plr.Character
local h      = char.Head
local t      = char.Torso
local ra     = char["Right Arm"]
local la     = char["Left Arm"]
local rl     = char["Right Leg"]
local ll     = char["Left Leg"]
local rut    = char.HumanoidRootPart
local hum    = char:FindFirstChildOfClass("Humanoid")
local necno  = t.Neck
local rutjno = rut.RootJoint
local rsno   = t["Right Shoulder"]
local lsno   = t["Left Shoulder"]
local rhno   = t["Right Hip"]
local lhno   = t["Left Hip"]
--
local change  = 1
local sine    = 0
local ws      = 8
local jp      = 35
local songPos = 1
local jok     = false
local sprint  = false
local sitting = false
local laying  = false
local crying  = false
local wsGrow  = false
local muted   = false
local anim    = "Idle"
local asset   = "rbxassetid://"
local songs = {
	2734040079,
	1179830130,
	152675132,
	1467405749,
	411386717,
	3517565766,
	509308446
}
--
necc0,necc1=cf(0,t.Size.Y/2,0),cf(0,-h.Size.Y/2,0)
rutjc0,rutjc1=cf(0,0,0),cf(0,0,0)
rsc0,rsc1=cf(t.Size.X/2,t.Size.Y/4,0),cf(-ra.Size.X/2,ra.Size.Y/4,0)
lsc0,lsc1=cf(-t.Size.X/2,t.Size.Y/4,0),cf(la.Size.X/2,la.Size.Y/4,0)
rhc0,rhc1=cf(t.Size.X/4,-t.Size.Y/2,0),cf(0,rl.Size.Y/2,0)
lhc0,lhc1=cf(-t.Size.X/4,-t.Size.Y/2,0),cf(0,ll.Size.Y/2,0)
if char:FindFirstChild("Animate") then
char.Animate:Destroy()
end
if hum:FindFirstChildOfClass("Animator") then
hum.Animator:Destroy()
end
--Creating new joints
local nec = ins("Motor6D",t) nec.Name = "Neck" nec.Part0 = t nec.Part1 = h
local rutj = ins("Motor6D",rut) rutj.Name = "RootJoint" rutj.Part0 = t rutj.Part1 = rut
local rs = ins("Motor6D",t) rs.Name = "Right Shoulder" rs.Part0 = t rs.Part1 = ra
local ls = ins("Motor6D",t) ls.Name = "Left Shoulder" ls.Part0 = t ls.Part1 = la
local rh = ins("Motor6D",t) rh.Name = "Right Hip" rh.Part0 = t rh.Part1 = rl
local lh = ins("Motor6D",t) lh.Name = "Left Hip" lh.Part0 = t lh.Part1 = ll
--Removing old joints
necno.Parent = nil
rutjno.Parent = nil
rsno.Parent = nil
lsno.Parent = nil
rhno.Parent = nil
lhno.Parent = nil
--Setting CFrames
nec.C1 = necc1
nec.C0 = necc0
rs.C1 = rsc1
rs.C0 = rsc0
ls.C1 = lsc1
ls.C0 = lsc0
rh.C1 = rhc1
rh.C0 = rhc0
lh.C1 = lhc1
lh.C0 = lhc0
rutj.C1 = rutjc1
rutj.C0 = rutjc0

local mus = Instance.New("Sound",{Looped = true,Volume = .5,SoundId = asset..songs[songPos],Parent = t})
local vroOm = Instance.New("Sound",{Looped = true,Volume = 7.5,SoundId = asset..2658538628,Parent = t})
if jok then
	mus:Play()
end

function swait()
	stepped:Wait()
end
function rayc(spos,direc,ignore,dist)
    return workspace:FindPartOnRayWithIgnoreList(ray(spos,direc.Unit * dist),ignore,false,false)
end
function tween(instance,args,info,playOnCreate)
	if instance and args then
		playOnCreate = playOnCreate or true
		info = info or TweenInfo.new(
			1,
			Enum.EasingStyle.Linear,
			Enum.EasingDirection.In,
			0,
			false,
			0
		)
		if typeof(info) == "table" then
			info = TweenInfo.new(unpack(info))
		end
		local tween = game:GetService("TweenService"):Create(instance,info,args)
		if playOnCreate then
			tween:Play()
		end
		return tween
	end
end

local function bindslol(input)
	if input == "leftcontrol" then
		sprint = not sprint
	elseif input == "n" then
		jok = not jok
	elseif input == "z" then
		sitting = not sitting
		laying = false
		crying = false
	elseif input == "x" then
		sitting = false
		laying = not laying
		crying = false
	elseif input == "c" then
		sitting = false
		laying = false
		crying = not crying
	elseif input == "l" then
		songPos = songPos + 1
		if songPos > #songs then
			songPos = 1
		end
		end
end

uis.InputBegan:Connect(function(io,ip)
	if ip then return end
	pcall(function()
		bindslol(io.KeyCode.Name:lower())
	end)
end)
uis.InputChanged:Connect(function(io,ip)
	if ip then return end
	pcall(function()
		bindslol(io.KeyCode.Name:lower())
	end)
end)

stepped:Connect(function()
	sine = sine + change
	
	local dir = hum.MoveDirection
	if dir.Magnitude == 0 then dir = rut.Velocity/10 end
	
    local Ccf		  = rut.CFrame
    local Walktest1   = dir*Ccf.LookVector
    local Walktest2   = dir*Ccf.RightVector
    local rotfb		  = Walktest1.X+Walktest1.Z
    local rotrl		  = Walktest2.X+Walktest2.Z
	
	local hit,pos,rot = rayc(rut.Position,-rut.CFrame.UpVector,{char},4.5)
	
	local verVel	  = rut.Velocity.y
    local horVel	  = (rut.Velocity * v3(1,0,1)).Magnitude
	
	if mus.Parent ~= t then
		Instance.Remove(mus)
		mus = Instance.New("Sound",{Looped = true,Volume = .5,SoundId = asset..songs[songPos],Parent = t})
		mus:Play()
	end
	if vroOm.Parent ~= t then
		Instance.Remove(vroOm)
		vroOm = Instance.New("Sound",{Looped = true,Volume = 7.5,SoundId = asset..2658538628,Parent = t})
	end
	if rotfb > 1 then
		rotfb = 1
	elseif rotfb < -1 then
		rotfb = -1
	end
	if rotrl > 1 then
		rotrl = 1
	elseif rotrl < -1 then
		rotrl = -1
	end
	
	if jok then
		if not sprint then
			ws = 16
		else
			if not wsGrow then
				ws = 6
			end
		end
		jp = 65
		if not muted then
			mus:Resume()
		else
			mus:Stop()
		end
	else
		if not sprint then
			ws = 8
		else
			ws = 38
		end
		jp = 35
		mus:Stop()
	end
	
	hum.WalkSpeed = ws
	hum.JumpPower = jp
	
	local sn = 0 if plr.Name == "vlad20020" and random(0,1,50) == .6 then sn = random(5,10) end
	
	if anim == "walk" and hit then
		if not jok then
			nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(sine/3) * 5,0,0,true) * angles(-rotfb/15,rotrl/2,0),.2)
			rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,.2 * cos(sine/3),0) * angles(sin(sine/3) * 2.5,sin(sine/6) * 2.5,0,true) * angles(-rotfb/12.5,0,-rotrl/8.5),.2)
			rs.C1 = rs.C1:Lerp(rsc1 * cf(.05 - .05 *  cos(sine/3),0,.1 * cos(sine/6) * rotfb) * angles(-10 - sin(sine/6) * 40 * rotfb,-sin(sine/6) * 25 * rotfb,0,true),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(-.05 + .05 *  cos(sine/3),0,-.1 * cos(sine/6) * rotfb) * angles(-10 + sin(sine/6) * 40 * rotfb,-sin(sine/6) * 25 * rotfb,0,true),.2)
			rh.C1 = rh.C1:Lerp(rhc1 * cf(0,.2 * cos(sine/6),.3 * -cos(sine/6)) * angles((7.5 * math.abs(rotfb)) + sin(sine/6) * 40 * rotfb,sin(sine/6) * 5,sin(sine/6) * 40 * rotrl,true),.2)
			lh.C1 = lh.C1:Lerp(lhc1 * cf(0,-.2 * cos(sine/6),.3 * cos(sine/6)) * angles((7.5 * math.abs(rotfb)) - sin(sine/6) * 40 * rotfb,sin(sine/6) * 5,-sin(sine/6) * 40 * rotrl,true),.2)
			wsGrow = false
			vroOm:Stop()
		else
			nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/5) * 15,sin(sine/10) * 20,0,true) * angles(-rotfb/10,rotrl/2,0),.2)
			rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,cos(sine/5) * 2.5,0) * angles(0,sin(sine/10) * 20,0,true) * angles(-rotfb/5,0,-rotrl/5),.2)
			rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,sin(sine/10) * 2.5 * rotfb) * angles(-15 + (sin(-sine/10) * 60 * rotfb),(-sin(sine/10) * 20) * rotfb,0,true),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,-sin(sine/10) * 2.5 * rotfb) * angles(-15 + (sin(sine/10) * 60 * rotfb),(-sin(sine/10) * 20) * rotfb,0,true),.2)
			rh.C1 = rh.C1:Lerp(rhc1 * cf((sin(sine/10) * 2.5) * rotrl,cos(sine/10) * 2.5,(-sin(sine/10) * 2.5) * rotfb) * angles(6.5 - (-sin(sine/10) * 35) * rotfb,sin(sine/10) * 10,(sin(sine/10) * 35) * rotrl,true),.2)
			lh.C1 = lh.C1:Lerp(lhc1 * cf((-sin(sine/10) * 2.5) * rotrl,-cos(sine/10) * 2.5,(sin(sine/10) * 2.5) * rotfb) * angles(6.5 - (sin(sine/10) * 35) * rotfb,sin(sine/10) * 10,(-sin(sine/10) * 35) * rotrl,true),.2)
			wsGrow = false
			vroOm:Stop()
		end
	elseif anim == "run" and hit then
		if not jok then
			nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(sine/3) * 7.5,sin(sine/6) * 5,0,true) * angles(-rotfb/10,rotrl/2,0),.2)
			rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,.4 * cos(sine/3),0) * angles(sin(sine/3) * 4,sin(sine/6) * 7.5,0,true) * angles(-rotfb/5,0,-rotrl/5),.2)
			rs.C1 = rs.C1:Lerp(rsc1 * cf(.1 - .1 *  cos(sine/3),0,-.15 - .2 * cos(sine/6) * rotfb) * angles(-15 - sin(sine/6) * 110 * rotfb,-sin(sine/6) * 25 * rotfb,-10,true),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(-.1 + .1 *  cos(sine/3),0,-.15 +.2 * cos(sine/6) * rotfb) * angles(-15 + sin(sine/6) * 110 * rotfb,-sin(sine/6) * 25 * rotfb,10,true),.2)
			rh.C1 = rh.C1:Lerp(rhc1 * cf(0,.5 * cos(sine/6),.75 * -cos(sine/6)) * angles((7.5 * math.abs(rotfb)) + (sin(sine/6) * 80 * rotfb),sin(sine/6) * 15,sin(sine/6) * 60 * rotrl,true),.2)
			lh.C1 = lh.C1:Lerp(lhc1 * cf(0,.5 * -cos(sine/6),.75 * cos(sine/6)) * angles((7.5 * math.abs(rotfb)) + (-sin(sine/6) * 80 * rotfb),sin(sine/6) * 15,-sin(sine/6) * 60 * rotrl,true),.2)
			wsGrow = false
			vroOm:Stop()
		else
			nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(0,0,0,true) * angles(-rotfb * 1.5,0,0),.2)
			rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,-math.abs(rotfb * 1.5) + 1 * sin(sine),0) * angles(sin(sine) * 25,0,cos(sine) * 15,true) * angles(-rotfb * 1.5,0,-rotrl * 1.5),.2)
			rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(-sine * 50 * (ws/750) * rotfb,sin(sine) * 200,sine * 50 * (ws/750) * rotrl,true),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(-sine * 50 * (ws/750) * rotfb,sin(sine) * 200,sine * 50 * (ws/750) * rotrl,true),.2)
			rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,1 * sin(sine/5) * 5 * (ws/750)) * angles(sine * 50 * (ws/750) * rotfb,0,sine * 50 * (ws/750) * rotrl,true),.2)
			lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,-1 * sin(sine/5) * 5 * (ws/750)) * angles(sine * 50 * (ws/750) * rotfb,0,sine * 50 * (ws/750) * rotrl,true),.2)
			vroOm:Resume()
			if vroOm.TimePosition > vroOm.TimeLength -.1 then
				vroOm.TimePosition = 8.5
			end
			if vroOm.TimePosition < .1 then
				ws = 6
			end
			if vroOm.TimePosition < 8.5 then
				ws = ws + .01
			else
				ws = 750
				wsGrow = true
			end
		end
	elseif anim == "jump" and not hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(0,0,0,true),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(0,0,0,true) * angles(-rotfb/5,0,-rotrl/5),.2)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(0,0,0,true),.2)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(0,0,0,true),.2)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(0,0,0,true),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(0,0,0,true),.2)
	elseif anim == "fall" and not hit then
		nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(0,0,0,true),.2)
		rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(0,0,0,true) * angles(-rotfb/5,0,-rotrl/5),.2)
		rs.C1 = rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(sin(sine/10) * 5,cos(sine/10) * 5,0,true),.2)
		ls.C1 = ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(-sin(sine/10) * 5,-cos(sine/10) * 5,0,true),.2)
		rh.C1 = rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(0,0,0,true),.2)
		lh.C1 = lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(0,0,0,true),.2)
	elseif anim == "idle" and hit then
		if not jok or sitting or laying or crying then
			nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(sine/20) * 4,sin(sine/80) * 10,0,true) * angles(random(-sn,sn),random(-sn,sn),random(-sn,sn),true),.2)
			rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(sin(sine/80)/20,sin(sine/20)/15,sin(sine/30)/17.5) * angles(sin(sine/20) * .9,sin(sine/60) * 2.25,sin(sine/80) * 2.25,true),.2)
			rs.C1 = rs.C1:Lerp(rsc1 * cf(0,sin(sine/20)/15,0) * angles((cos(sine/20) * 4),sin(sine/20) * 1.8,(sin(sine/80) * 2.25) + (cos(sine/20) * 2.25),true),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(0,sin(sine/20)/15,0) * angles((cos(sine/20) * 4),-sin(sine/20) * 1.8,(sin(sine/80) * 2.25) + (-cos(sine/20) * 2.25),true),.2)
			rh.C1 = rh.C1:Lerp(rhc1 * cf(0,(sin(sine/20)/15) + (sin(sine/80)/25),0) * angles((sin(sine/20) * 1.8) - (sin(sine/30) * 2.25) + (sin(sine/60) * 1.35),sin(sine/60) * 2.25,(sin(sine/80) * 3.25),true),.2)
			lh.C1 = lh.C1:Lerp(lhc1 * cf(0,(sin(sine/20)/15) - (sin(sine/80)/25),0) * angles((sin(sine/20) * 1.8) - (sin(sine/30) * 2.25) - (sin(sine/60) * 1.35),sin(sine/60) * 2.25,(sin(sine/80) * 3.25),true),.2)
			wsGrow = false
			vroOm:Stop()
		elseif jok and not sitting and not laying and not crying then
			nec.C1 = nec.C1:Lerp(necc1 * cf(0,0,0) * angles(-cos(sine/10) * sin(sine/20) * 45,sin(sine/20) * cos(sine/40) * 30,sin(sine/30) * cos(sine/60) * 20,true),.2)
			rutj.C1 = rutj.C1:Lerp(rutjc1 * cf(.25 * sin(sine/30) * cos(sine/60),-.65 + 1 * sin(sine/10) * cos(sine/20),0) * angles(sin(sine/10) * cos(sine/20) * 35,0,sin(sine/30) * cos(sine/60) * 10,true),.2)
			rs.C1 = rs.C1:Lerp(rsc1 * cf(0,.25 - .25 * sin(sine/20) * cos(sine/10),.25 * sin(sine/10) * cos(sine/20)) * angles(-105 + sin(sine/20) * cos(sine/10) * 65,sin(sine/20) * cos(sine/60) * 5,sin(sine/10) * cos(sine/20) * 70,true),.2)
			ls.C1 = ls.C1:Lerp(lsc1 * cf(0,.25 - .25 * sin(sine/20) * cos(sine/10),.25 * sin(sine/10) * cos(sine/20)) * angles(-105 + sin(sine/20) * cos(sine/10) * 65,sin(sine/20) * cos(sine/60) * 5,sin(sine/10) * cos(sine/20) * -70,true),.2)
			rh.C1 = rh.C1:Lerp(rhc1 * cf(0,-.625 + 1 * sin(sine/10) * cos(sine/20),.25 - .5 * sin(sine/10) * cos(sine/20)) * angles(10 + sin(sine/10) * cos(sine/20) * 40,0,sin(sine/30) * cos(sine/60) * 17.5,true),.2)
			lh.C1 = lh.C1:Lerp(lhc1 * cf(0,-.625 + 1 * sin(sine/10) * cos(sine/20),.25 - .5 * sin(sine/10) * cos(sine/20)) * angles(10 + sin(sine/10) * cos(sine/20) * 40,0,sin(sine/30) * cos(sine/60) * 17.5,true),.2)
			wsGrow = false
			vroOm:Stop()
		end
	end
	
	if verVel > 20 then
		anim = "jump"
		change = 1
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(5,0,0,true),.2)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(-5,0,0,true),.2)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(0,-.15,-.25) * angles(150,10,12.5,true),.2)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.15,-.25) * angles(155,-10,-12.5,true),.2)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.5,-.35) * angles(-12.5,0,5,true),.2)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.2,-.15) * angles(-2.5,0,-5,true),.2)
	elseif verVel < -20 then
		anim = "fall"
		change = 1
		nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(-7.5,0,0,true),.2)
		rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(5,0,0,true),.2)
		rs.C0 = rs.C0:Lerp(rsc0 * cf(.25,-.25,0) * angles(0,10,110,true),.2)
		ls.C0 = ls.C0:Lerp(lsc0 * cf(-.25,-.25,0) * angles(0,-10,-110,true),.2)
		rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.2,-.15) * angles(-2.5,0,5,true),.2)
		lh.C0 = lh.C0:Lerp(lhc0 * cf(0,.5,-.35) * angles(-12.5,0,-5,true),.2)
	elseif horVel > 5 and verVel > -20 and verVel < 20 then
		if not sprint then
			anim = "walk"
			if not jok then
				change = .6
			else
				change = 1
			end
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,0,0,true),.2)
		else
			anim = "run"
			if not jok then
				change = .9
			else
				change = 1
			end
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0,0,0,true),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,0,0,true),.2)
		end
	elseif horVel < 5 and verVel > -20 and verVel < 20 then
		anim = "idle"
		change = 1
		if not sitting and not laying and not crying then
			if not jok then
				nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true),.2)
				rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true),.2)
				rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(.5,0,-.5,true),.2)
				ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(.5,0,.5,true),.2)
				rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0,-2.5,2,true),.2)
				lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,2.5,-2,true),.2)
			else
				nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true),.2)
				rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true),.2)
				rs.C0 = rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(0,0,0,true),.2)
				ls.C0 = ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(0,0,0,true),.2)
				rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0,0,5,true),.2)
				lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,0,-5,true),.2)
			end
		elseif sitting and not laying and not crying then
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(-20,0,0,true),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,1.75,0) * angles(-15,0,0,true),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(-.1,-.5,.15) * angles(-20,-60,10,true),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(0,-.25,-.2) * angles(70,-60,60,true) * angles(40,0,0,true),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(70,7.5,5,true),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,1.25,-.5) * angles(10,-10,-5,true),.2)
		elseif not sitting and laying and not crying then
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(-35,0,0,true),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,0,-2.4) * angles(-87.5,0,0,true),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(-.1,.75,-.25) * angles(195,0,-65,true) * angles(0,90,0,true),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(.125,-.3,-.05) * angles(90,20,85,true) * angles(-30,20,0,true),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,.25,-1) * angles(-55,20,7.5,true),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(2,-7.5,5,true),.2)
		elseif not sitting and not laying and crying then
			nec.C0 = nec.C0:Lerp(necc0 * cf(0,0,0) * angles(-80,0,0,true),.2)
			rutj.C0 = rutj.C0:Lerp(rutjc0 * cf(0,1.9,0) * angles(10,0,0,true),.2)
			rs.C0 = rs.C0:Lerp(rsc0 * cf(-.25,-.475,-.8) * angles(85,0,-80,true) * angles(0,100,0,true),.2)
			ls.C0 = ls.C0:Lerp(lsc0 * cf(.25,-.4,-.75) * angles(80,0,85,true) * angles(0,-87.5,0,true),.2)
			rh.C0 = rh.C0:Lerp(rhc0 * cf(0,1.85,-.75) * angles(5,-5,-5,true),.2)
			lh.C0 = lh.C0:Lerp(lhc0 * cf(0,1.85,-.7) * angles(3.5,5,5,true),.2)
		end
		end
end)
end

local function snipermeowz()
	local rightarm = {"RARM";"International Fedora"}
local leftarm = {"LARM";"Robloxclassicred"}
local rightleg = {"MeshPartAccessory";"RCap"}
local leftleg = {"Unloaded head";"RunningBull"}
local torso = {"Black";"MediHood";"Accessory (White Torso)"}
local rifle = {"Starslayer Railgun"}
game.Players.LocalPlayer.Character.Archivable = true
local fakechar = game.Players.LocalPlayer.Character:Clone()
fakechar.Parent = game.Workspace
for i,v in pairs(fakechar:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end
fakechar.Head.face.Transparency = 1
game.Players.LocalPlayer.Character.Parent = fakechar
local realchar = fakechar[game.Players.LocalPlayer.Name]
for i,v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do if v:IsA("Tool") then v.Parent = game.Players.LocalPlayer.Character end end
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
fakechar.Animate.Disabled = true
fakechar.Animate.Enabled = true
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) or table.find(rifle,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CFrame = game.Players.LocalPlayer:GetMouse().Hit end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CanCollide = false end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.AssemblyAngularVelocity = Vector3.new(6400,6400,6400) end end
		task.wait()
	end
end)
game.Players.LocalPlayer.CharacterAdded:Connect(function()
task.wait(.1)
game.Players.LocalPlayer.Character.Parent = fakechar
realchar = fakechar[game.Players.LocalPlayer.Name]
for i,v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do if v:IsA("Tool") then v.Parent = game.Players.LocalPlayer.Character end end
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) or table.find(rifle,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CFrame = game.Players.LocalPlayer:GetMouse().Hit end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CanCollide = false end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.AssemblyAngularVelocity = Vector3.new(6400,6400,6400) end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rifle,v.Name) then v.Handle.CFrame = fakechar["WeaponModel"].Handle.CFrame * CFrame.Angles(0,-2.57,1) end end end
		task.wait()
	end
end)
end)
game.Players.LocalPlayer.SimulationRadius = 9999
function LoadLibrary(a)
	local t = {}

	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------JSON Functions Begin----------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------

	--JSON Encoder and Parser for Lua 5.1
	--
	--Copyright 2007 Shaun Brown  (http://www.chipmunkav.com)
	--All Rights Reserved.

	--Permission is hereby granted, free of charge, to any person 
	--obtaining a copy of this software to deal in the Software without 
	--restriction, including without limitation the rights to use, 
	--copy, modify, merge, publish, distribute, sublicense, and/or 
	--sell copies of the Software, and to permit persons to whom the 
	--Software is furnished to do so, subject to the following conditions:

	--The above copyright notice and this permission notice shall be 
	--included in all copies or substantial portions of the Software.
	--If you find this software useful please give www.chipmunkav.com a mention.

	--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
	--EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
	--OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	--IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
	--ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
	--CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
	--CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	local string = string
	local math = math
	local table = table
	local error = error
	local tonumber = tonumber
	local tostring = tostring
	local type = type
	local setmetatable = setmetatable
	local pairs = pairs
	local ipairs = ipairs
	local assert = assert


	local StringBuilder = {
		buffer = {}
	}

	function StringBuilder:New()
		local o = {}
		setmetatable(o, self)
		self.__index = self
		o.buffer = {}
		return o
	end

	function StringBuilder:Append(s)
		self.buffer[#self.buffer+1] = s
	end

	function StringBuilder:ToString()
		return table.concat(self.buffer)
	end

	local JsonWriter = {
		backslashes = {
			['\b'] = "\\b",
			['\t'] = "\\t",	
			['\n'] = "\\n", 
			['\f'] = "\\f",
			['\r'] = "\\r", 
			['"']  = "\\\"", 
			['\\'] = "\\\\", 
			['/']  = "\\/"
		}
	}

	function JsonWriter:New()
		local o = {}
		o.writer = StringBuilder:New()
		setmetatable(o, self)
		self.__index = self
		return o
	end

	function JsonWriter:Append(s)
		self.writer:Append(s)
	end

	function JsonWriter:ToString()
		return self.writer:ToString()
	end

	function JsonWriter:Write(o)
		local t = type(o)
		if t == "nil" then
			self:WriteNil()
		elseif t == "boolean" then
			self:WriteString(o)
		elseif t == "number" then
			self:WriteString(o)
		elseif t == "string" then
			self:ParseString(o)
		elseif t == "table" then
			self:WriteTable(o)
		elseif t == "function" then
			self:WriteFunction(o)
		elseif t == "thread" then
			self:WriteError(o)
		elseif t == "userdata" then
			self:WriteError(o)
		end
	end

	function JsonWriter:WriteNil()
		self:Append("null")
	end

	function JsonWriter:WriteString(o)
		self:Append(tostring(o))
	end

	function JsonWriter:ParseString(s)
		self:Append('"')
		self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
			local c = self.backslashes[n]
			if c then return c end
			return string.format("\\u%.4X", string.byte(n))
		end))
		self:Append('"')
	end

	function JsonWriter:IsArray(t)
		local count = 0
		local isindex = function(k) 
			if type(k) == "number" and k > 0 then
				if math.floor(k) == k then
					return true
				end
			end
			return false
		end
		for k,v in pairs(t) do
			if not isindex(k) then
				return false, '{', '}'
			else
				count = math.max(count, k)
			end
		end
		return true, '[', ']', count
	end

	function JsonWriter:WriteTable(t)
		local ba, st, et, n = self:IsArray(t)
		self:Append(st)	
		if ba then		
			for i = 1, n do
				self:Write(t[i])
				if i < n then
					self:Append(',')
				end
			end
		else
			local first = true;
			for k, v in pairs(t) do
				if not first then
					self:Append(',')
				end
				first = false;			
				self:ParseString(k)
				self:Append(':')
				self:Write(v)			
			end
		end
		self:Append(et)
	end

	function JsonWriter:WriteError(o)
		error(string.format(
			"Encoding of %s unsupported", 
			tostring(o)))
	end

	function JsonWriter:WriteFunction(o)
		if o == Null then 
			self:WriteNil()
		else
			self:WriteError(o)
		end
	end

	local StringReader = {
		s = "",
		i = 0
	}

	function StringReader:New(s)
		local o = {}
		setmetatable(o, self)
		self.__index = self
		o.s = s or o.s
		return o	
	end

	function StringReader:Peek()
		local i = self.i + 1
		if i <= #self.s then
			return string.sub(self.s, i, i)
		end
		return nil
	end

	function StringReader:Next()
		self.i = self.i+1
		if self.i <= #self.s then
			return string.sub(self.s, self.i, self.i)
		end
		return nil
	end

	function StringReader:All()
		return self.s
	end

	local JsonReader = {
		escapes = {
			['t'] = '\t',
			['n'] = '\n',
			['f'] = '\f',
			['r'] = '\r',
			['b'] = '\b',
		}
	}

	function JsonReader:New(s)
		local o = {}
		o.reader = StringReader:New(s)
		setmetatable(o, self)
		self.__index = self
		return o;
	end

	function JsonReader:Read()
		self:SkipWhiteSpace()
		local peek = self:Peek()
		if peek == nil then
			error(string.format(
				"Nil string: '%s'", 
				self:All()))
		elseif peek == '{' then
			return self:ReadObject()
		elseif peek == '[' then
			return self:ReadArray()
		elseif peek == '"' then
			return self:ReadString()
		elseif string.find(peek, "[%+%-%d]") then
			return self:ReadNumber()
		elseif peek == 't' then
			return self:ReadTrue()
		elseif peek == 'f' then
			return self:ReadFalse()
		elseif peek == 'n' then
			return self:ReadNull()
		elseif peek == '/' then
			self:ReadComment()
			return self:Read()
		else
			return nil
		end
	end

	function JsonReader:ReadTrue()
		self:TestReservedWord{'t','r','u','e'}
		return true
	end

	function JsonReader:ReadFalse()
		self:TestReservedWord{'f','a','l','s','e'}
		return false
	end

	function JsonReader:ReadNull()
		self:TestReservedWord{'n','u','l','l'}
		return nil
	end

	function JsonReader:TestReservedWord(t)
		for i, v in ipairs(t) do
			if self:Next() ~= v then
				error(string.format(
					"Error reading '%s': %s", 
					table.concat(t), 
					self:All()))
			end
		end
	end

	function JsonReader:ReadNumber()
		local result = self:Next()
		local peek = self:Peek()
		while peek ~= nil and string.find(
			peek, 
			"[%+%-%d%.eE]") do
			result = result .. self:Next()
			peek = self:Peek()
		end
		result = tonumber(result)
		if result == nil then
			error(string.format(
				"Invalid number: '%s'", 
				result))
		else
			return result
		end
	end

	function JsonReader:ReadString()
		local result = ""
		assert(self:Next() == '"')
		while self:Peek() ~= '"' do
			local ch = self:Next()
			if ch == '\\' then
				ch = self:Next()
				if self.escapes[ch] then
					ch = self.escapes[ch]
				end
			end
			result = result .. ch
		end
		assert(self:Next() == '"')
		local fromunicode = function(m)
			return string.char(tonumber(m, 16))
		end
		return string.gsub(
			result, 
			"u%x%x(%x%x)", 
			fromunicode)
	end

	function JsonReader:ReadComment()
		assert(self:Next() == '/')
		local second = self:Next()
		if second == '/' then
			self:ReadSingleLineComment()
		elseif second == '*' then
			self:ReadBlockComment()
		else
			error(string.format(
				"Invalid comment: %s", 
				self:All()))
		end
	end

	function JsonReader:ReadBlockComment()
		local done = false
		while not done do
			local ch = self:Next()		
			if ch == '*' and self:Peek() == '/' then
				done = true
			end
			if not done and 
				ch == '/' and 
				self:Peek() == "*" then
				error(string.format(
					"Invalid comment: %s, '/*' illegal.",  
					self:All()))
			end
		end
		self:Next()
	end

	function JsonReader:ReadSingleLineComment()
		local ch = self:Next()
		while ch ~= '\r' and ch ~= '\n' do
			ch = self:Next()
		end
	end

	function JsonReader:ReadArray()
		local result = {}
		assert(self:Next() == '[')
		local done = false
		if self:Peek() == ']' then
			done = true;
		end
		while not done do
			local item = self:Read()
			result[#result+1] = item
			self:SkipWhiteSpace()
			if self:Peek() == ']' then
				done = true
			end
			if not done then
				local ch = self:Next()
				if ch ~= ',' then
					error(string.format(
						"Invalid array: '%s' due to: '%s'", 
						self:All(), ch))
				end
			end
		end
		assert(']' == self:Next())
		return result
	end

	function JsonReader:ReadObject()
		local result = {}
		assert(self:Next() == '{')
		local done = false
		if self:Peek() == '}' then
			done = true
		end
		while not done do
			local key = self:Read()
			if type(key) ~= "string" then
				error(string.format(
					"Invalid non-string object key: %s", 
					key))
			end
			self:SkipWhiteSpace()
			local ch = self:Next()
			if ch ~= ':' then
				error(string.format(
					"Invalid object: '%s' due to: '%s'", 
					self:All(), 
					ch))
			end
			self:SkipWhiteSpace()
			local val = self:Read()
			result[key] = val
			self:SkipWhiteSpace()
			if self:Peek() == '}' then
				done = true
			end
			if not done then
				ch = self:Next()
				if ch ~= ',' then
					error(string.format(
						"Invalid array: '%s' near: '%s'", 
						self:All(), 
						ch))
				end
			end
		end
		assert(self:Next() == "}")
		return result
	end

	function JsonReader:SkipWhiteSpace()
		local p = self:Peek()
		while p ~= nil and string.find(p, "[%s/]") do
			if p == '/' then
				self:ReadComment()
			else
				self:Next()
			end
			p = self:Peek()
		end
	end

	function JsonReader:Peek()
		return self.reader:Peek()
	end

	function JsonReader:Next()
		return self.reader:Next()
	end

	function JsonReader:All()
		return self.reader:All()
	end

	function Encode(o)
		local writer = JsonWriter:New()
		writer:Write(o)
		return writer:ToString()
	end

	function Decode(s)
		local reader = JsonReader:New(s)
		return reader:Read()
	end

	function Null()
		return Null
	end
	-------------------- End JSON Parser ------------------------

	t.DecodeJSON = function(jsonString)
		pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

		if type(jsonString) == "string" then
			return Decode(jsonString)
		end
		print("RbxUtil.DecodeJSON expects string argument!")
		return nil
	end

	t.EncodeJSON = function(jsonTable)
		pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
		return Encode(jsonTable)
	end








	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	--makes a wedge at location x, y, z
	--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
	--returns true if made a wedge, false if the cell remains a block
	t.MakeWedge = function(x, y, z, defaultmaterial)
		return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
	end

	t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
		local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
		if not terrain then return end

		assert(regionToSelect)
		assert(color)

		if not type(regionToSelect) == "Region3" then
			error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
		end
		if not type(color) == "BrickColor" then
			error("color (second arg), should be of type BrickColor, but is type",type(color))
		end

		-- frequently used terrain calls (speeds up call, no lookup necessary)
		local GetCell = terrain.GetCell
		local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
		local CellCenterToWorld = terrain.CellCenterToWorld
		local emptyMaterial = Enum.CellMaterial.Empty

		-- container for all adornments, passed back to user
		local selectionContainer = Instance.new("Model")
		selectionContainer.Name = "SelectionContainer"
		selectionContainer.Archivable = false
		if selectionParent then
			selectionContainer.Parent = selectionParent
		else
			selectionContainer.Parent = game:GetService("Workspace")
		end

		local updateSelection = nil -- function we return to allow user to update selection
		local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
		local aliveCounter = 0 -- helper for currentKeepAliveTag
		local lastRegion = nil -- used to stop updates that do nothing
		local adornments = {} -- contains all adornments
		local reusableAdorns = {}

		local selectionPart = Instance.new("Part")
		selectionPart.Name = "SelectionPart"
		selectionPart.Transparency = 1
		selectionPart.Anchored = true
		selectionPart.Locked = true
		selectionPart.CanCollide = false
		selectionPart.Size = Vector3.new(4.2,4.2,4.2)

		local selectionBox = Instance.new("SelectionBox")

		-- srs translation from region3 to region3int16
		local function Region3ToRegion3int16(region3)
			local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
			local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

			local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
			local highCell = WorldToCellPreferSolid(terrain, theHighVec)

			local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
			local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

			return Region3int16.new(lowIntVec,highIntVec)
		end

		-- helper function that creates the basis for a selection box
		function createAdornment(theColor)
			local selectionPartClone = nil
			local selectionBoxClone = nil

			if #reusableAdorns > 0 then
				selectionPartClone = reusableAdorns[1]["part"]
				selectionBoxClone = reusableAdorns[1]["box"]
				table.remove(reusableAdorns,1)

				selectionBoxClone.Visible = true
			else
				selectionPartClone = selectionPart:Clone()
				selectionPartClone.Archivable = false

				selectionBoxClone = selectionBox:Clone()
				selectionBoxClone.Archivable = false

				selectionBoxClone.Adornee = selectionPartClone
				selectionBoxClone.Parent = selectionContainer

				selectionBoxClone.Adornee = selectionPartClone

				selectionBoxClone.Parent = selectionContainer
			end

			if theColor then
				selectionBoxClone.Color = theColor
			end

			return selectionPartClone, selectionBoxClone
		end

		-- iterates through all current adornments and deletes any that don't have latest tag
		function cleanUpAdornments()
			for cellPos, adornTable in pairs(adornments) do

				if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
					adornTable.SelectionBox.Visible = false
					table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
					adornments[cellPos] = nil
				end
			end
		end

		-- helper function to update tag
		function incrementAliveCounter()
			aliveCounter = aliveCounter + 1
			if aliveCounter > 1000000 then
				aliveCounter = 0
			end
			return aliveCounter
		end

		-- finds full cells in region and adorns each cell with a box, with the argument color
		function adornFullCellsInRegion(region, color)
			local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
			local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

			local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
			local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

			currentKeepAliveTag = incrementAliveCounter()
			for y = cellPosBegin.y, cellPosEnd.y do
				for z = cellPosBegin.z, cellPosEnd.z do
					for x = cellPosBegin.x, cellPosEnd.x do
						local cellMaterial = GetCell(terrain, x, y, z)

						if cellMaterial ~= emptyMaterial then
							local cframePos = CellCenterToWorld(terrain, x, y, z)
							local cellPos = Vector3int16.new(x,y,z)

							local updated = false
							for cellPosAdorn, adornTable in pairs(adornments) do
								if cellPosAdorn == cellPos then
									adornTable.KeepAlive = currentKeepAliveTag
									if color then
										adornTable.SelectionBox.Color = color
									end
									updated = true
									break
								end 
							end

							if not updated then
								local selectionPart, selectionBox = createAdornment(color)
								selectionPart.Size = Vector3.new(4,4,4)
								selectionPart.CFrame = CFrame.new(cframePos)
								local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
								adornments[cellPos] = adornTable
							end
						end
					end
				end
			end
			cleanUpAdornments()
		end


		------------------------------------- setup code ------------------------------
		lastRegion = regionToSelect

		if selectEmptyCells then -- use one big selection to represent the area selected
			local selectionPart, selectionBox = createAdornment(color)

			selectionPart.Size = regionToSelect.Size
			selectionPart.CFrame = regionToSelect.CFrame

			adornments.SelectionPart = selectionPart
			adornments.SelectionBox = selectionBox

			updateSelection = 
				function (newRegion, color)
					if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						selectionPart.Size = newRegion.Size
						selectionPart.CFrame = newRegion.CFrame
					end
					if color then
						selectionBox.Color = color
					end
				end
		else -- use individual cell adorns to represent the area selected
			adornFullCellsInRegion(regionToSelect, color)
			updateSelection = 
				function (newRegion, color)
					if newRegion and newRegion ~= lastRegion then
						lastRegion = newRegion
						adornFullCellsInRegion(newRegion, color)
					end
				end

		end

		local destroyFunc = function()
			updateSelection = nil
			if selectionContainer then selectionContainer:Destroy() end
			adornments = nil
		end

		return updateSelection, destroyFunc
	end

	-----------------------------Terrain Utilities End-----------------------------







	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------Signal class begin------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function 
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
	Arguments:   The function to connect to.
	Returns:     A new connection object which can be used to disconnect the connection
	Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
	             the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
	             connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
	             NOT mean that the first will be called before the second as a result of a call to |fire|.

Method :disconnect()
	Arguments:   None
	Returns:     None
	Description: Disconnects all of the functions connected to this signal.

Method :fire( ... )
	Arguments:   Any arguments are accepted
	Returns:     None
	Description: Calls all of the currently connected functions with the given arguments.

Method :wait()
	Arguments:   None
	Returns:     The arguments given to fire
	Description: This call blocks until 
]]

	function t.CreateSignal()
		local this = {}

		local mBindableEvent = Instance.new('BindableEvent')
		local mAllCns = {} --all connection objects returned by mBindableEvent::connect

		--main functions
		function this:connect(func)
			if self ~= this then error("connect must be called with `:`, not `.`", 2) end
			if type(func) ~= 'function' then
				error("Argument #1 of connect must be a function, got a "..type(func), 2)
			end
			local cn = mBindableEvent.Event:Connect(func)
			mAllCns[cn] = true
			local pubCn = {}
			function pubCn:disconnect()
				cn:Disconnect()
				mAllCns[cn] = nil
			end
			pubCn.Disconnect = pubCn.disconnect

			return pubCn
		end

		function this:disconnect()
			if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
			for cn, _ in pairs(mAllCns) do
				cn:Disconnect()
				mAllCns[cn] = nil
			end
		end

		function this:wait()
			if self ~= this then error("wait must be called with `:`, not `.`", 2) end
			return mBindableEvent.Event:Wait()
		end

		function this:fire(...)
			if self ~= this then error("fire must be called with `:`, not `.`", 2) end
			mBindableEvent:Fire(...)
		end

		this.Connect = this.connect
		this.Disconnect = this.disconnect
		this.Wait = this.wait
		this.Fire = this.fire

		return this
	end

	------------------------------------------------- Sigal class End ------------------------------------------------------




	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------Create Function Begins---------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in 
which case it simply creates an object of the given type, or a table argument that may contain several types of data, 
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
      Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
      ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
      |Create| call's body.

2) An integral key mapping to another Instance:
      Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
      parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
      need for temporary variables to store references to those objects.

3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
      The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy 
      for those who really want such a functionality. The name of the event whose name is passed to 
      Create.E( string )

4) A key which is the Create function itself, and a value which is a function
      The function will be run with the argument of the object itself after all other initialization of the object is 
      done by create. This provides a way to do arbitrary things involving the object from withing the create 
      hierarchy. 
      Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
      it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the 
      constructor callback function is possible, it is probably not a good design choice.
      Note: Since the constructor function is called after all other initialization, a Create block cannot have two 
      constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.


Some example usages:

A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
    Name = 'A New model',
    Parent = game.Workspace,
}


An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
 |-ObjectValue
 |  |
 |  `-BoolValueChild
 `-IntValue

local model = Create'Model'{
    Name = 'Model_Container',
    Create'ObjectValue'{
        Create'BoolValue'{
            Name = 'BoolValueChild',
        },
    },
    Create'IntValue'{},
}


An example using the event syntax:

local part = Create'Part'{
    [Create.E'Touched'] = function(part)
        print("I was touched by "..part.Name)
    end,	
}


An example using the general constructor syntax:

local model = Create'Part'{
    [Create] = function(this)
        print("Constructor running!")
        this.Name = GetGlobalFoosAndBars(this)
    end,
}


Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
      any unexpected behavior. EG:
      local partCreatingFunction = Create'Part'
      local part = partCreatingFunction()
]]

	--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
	--will be created in several steps rather than as a single function declaration.
	local function Create_PrivImpl(objectType)
		if type(objectType) ~= 'string' then
			error("Argument of Create must be a string", 2)
		end
		--return the proxy function that gives us the nice Create'string'{data} syntax
		--The first function call is a function call using Lua's single-string-argument syntax
		--The second function call is using Lua's single-table-argument syntax
		--Both can be chained together for the nice effect.
		return function(dat)
			--default to nothing, to handle the no argument given case
			dat = dat or {}

			--make the object to mutate
			local obj = Instance.new(objectType)
			local parent = nil

			--stored constructor function to be called after other initialization
			local ctor = nil

			for k, v in pairs(dat) do
				--add property
				if type(k) == 'string' then
					if k == 'Parent' then
						-- Parent should always be set last, setting the Parent of a new object
						-- immediately makes performance worse for all subsequent property updates.
						parent = v
					else
						obj[k] = v
					end


					--add child
				elseif type(k) == 'number' then
					if type(v) ~= 'userdata' then
						error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
					end
					v.Parent = obj


					--event connect
				elseif type(k) == 'table' and k.__eventname then
					if type(v) ~= 'function' then
						error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
					       got: "..tostring(v), 2)
					end
					obj[k.__eventname]:connect(v)


					--define constructor function
				elseif k == t.Create then
					if type(v) ~= 'function' then
						error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
					       got: "..tostring(v), 2)
					elseif ctor then
						--ctor already exists, only one allowed
						error("Bad entry in Create body: Only one constructor function is allowed", 2)
					end
					ctor = v


				else
					error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
				end
			end

			--apply constructor function if it exists
			if ctor then
				ctor(obj)
			end

			if parent then
				obj.Parent = parent
			end

			--return the completed object
			return obj
		end
	end

	--now, create the functor:
	t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

	--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
	--function can recognize as special.
	t.Create.E = function(eventName)
		return {__eventname = eventName}
	end

	-------------------------------------------------Create function End----------------------------------------------------




	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------Documentation Begin-----------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------

	t.Help = 
		function(funcNameOrFunc) 
			--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
			if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
				return "Function DecodeJSON.  " ..
				"Arguments: (string).  " .. 
				"Side effect: returns a table with all parsed JSON values" 
			end
			if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
				return "Function EncodeJSON.  " ..
				"Arguments: (table).  " .. 
				"Side effect: returns a string composed of argument table in JSON data format" 
			end  
			if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
				return "Function MakeWedge. " ..
				"Arguments: (x, y, z, [default material]). " ..
				"Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
				"parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
				"Returns true if made a wedge, false if the cell remains a block "
			end
			if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
				return "Function SelectTerrainRegion. " ..
				"Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
				"Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
				"(this should be a region3 value). The selection box color is detemined by the color argument " ..
				"(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
				"SelectEmptyCells is bool, when true will select all cells in the " ..
				"region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
				"arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
				"Also returns a second function that takes no arguments and destroys the selection"
			end
			if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
				return "Function CreateSignal. "..
				"Arguments: None. "..
				"Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
				"used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
				"Lua code. "..
				"Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
				"For more info you can pass the method name to the Help function, or view the wiki page "..
				"for this library. EG: Help('Signal:connect')."
			end
			if funcNameOrFunc == "Signal:connect" then
				return "Method Signal:connect. "..
				"Arguments: (function handler). "..
				"Return: A connection object which can be used to disconnect the connection to this handler. "..
				"Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
				"handler function will be called with the arguments passed to |fire|."
			end
			if funcNameOrFunc == "Signal:wait" then
				return "Method Signal:wait. "..
				"Arguments: None. "..
				"Returns: The arguments passed to the next call to |fire|. "..
				"Description: This call does not return until the next call to |fire| is made, at which point it "..
				"will return the values which were passed as arguments to that |fire| call."
			end
			if funcNameOrFunc == "Signal:fire" then
				return "Method Signal:fire. "..
				"Arguments: Any number of arguments of any type. "..
				"Returns: None. "..
				"Description: This call will invoke any connected handler functions, and notify any waiting code "..
				"attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
				"to handlers are made asynchronously, so this call will return immediately regardless of how long "..
				"it takes the connected handler functions to complete."
			end
			if funcNameOrFunc == "Signal:disconnect" then
				return "Method Signal:disconnect. "..
				"Arguments: None. "..
				"Returns: None. "..
				"Description: This call disconnects all handlers attacched to this function, note however, it "..
				"does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
				"can also be called on the connection object which is returned from Signal:connect to only "..
				"disconnect a single handler, as opposed to this method, which will disconnect all handlers."
			end
			if funcNameOrFunc == "Create" then
				return "Function Create. "..
				"Arguments: A table containing information about how to construct a collection of objects. "..
				"Returns: The constructed objects. "..
				"Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
				"is best described via example, please see the wiki page for a description of how to use it."
			end
		end

	--------------------------------------------Documentation Ends----------------------------------------------------------

	return t
end
-- put scripts under here! --
Ply = game.Players.LocalPlayer
Char = Ply.Character
Tor = Char.Torso
He = Char.Head
Ne = Tor.Neck
Hu = Char.Humanoid
LA = Char["Left Arm"] 
LL = Char["Left Leg"] 
RA = Char["Right Arm"] 
RL = Char["Right Leg"]
LS = Tor["Left Shoulder"] 
RS = Tor["Right Shoulder"] 
LH = Tor["Left Hip"] 
RH = Tor["Right Hip"] 
Combo = 1
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RP = Char.HumanoidRootPart
RJ = RP.RootJoint
RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
LHCF = CFrame.Angles(0, math.rad(-90), 0)
RHCF = CFrame.Angles(0, math.rad(90), 0)
attack = false
equipped = false
local Anim = "Idle"
Effects = { }
cam = workspace.CurrentCamera
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
local m = Create("Model"){
	Parent = Char,
	Name = "WeaponModel",
}

RS.Parent = nil 
LS.Parent = nil 

RW = Create("Weld"){
	Name = "Right Shoulder",
	Part0 = Tor ,
	C0 = CFrame.new(1.5, 0.5, 0),
	C1 = CFrame.new(0, 0.5, 0), 
	Part1 = RA ,
	Parent = Tor ,
}

LW = Create("Weld"){
	Name = "Left Shoulder",
	Part0 = Tor ,
	C0 = CFrame.new(-1.5, 0.5, 0),
	C1 = CFrame.new(0, 0.5, 0) ,
	Part1 = LA ,
	Parent = Tor ,
}

mouse = Ply:GetMouse()

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreatePart(FF, Par, Mat, Ref, Tra, BC, Nam, Siz)
	local Part = Create("Part"){
		formFactor = FF,
		Parent = Par,
		Reflectance = Ref,
		Transparency = 1,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BC)),
		Name = Nam,
		Size = Siz,
		Position = Tor.Position,
		Material = Mat,
	}
	RemoveOutlines(Part)
	return Part
end

function CreateMesh(Ms, Par, MType, MId, OS, Sca)
	local Msh = Create(Ms){
		Parent = Par,
		Offset = OS,
		Scale = Sca,
	}
	if Ms == "SpecialMesh" then
		Msh.MeshType = MType
		Msh.MeshId = MId
	end
end

function CreateWeld(Par, PartA, PartB, CA, CB)
	local Weld = Create("Weld"){
		Parent = Par,
		Part0 = PartA,
		Part1 = PartB,
		C0 = CA,
		C1 = CB,
	}
	return Weld
end

function CreateSound(id, par, vol, pit) 
	coroutine.resume(coroutine.create(function()
		local sou = Create("Sound"){
			Parent = par or workspace,
			Volume = vol,
			Pitch = pit or 1,
			SoundId = id,
		}
		wait() 
		sou:play() 
	end))
end

function clerp(a, b, t)
	return a:lerp(b, t)
end

function rayCast(Pos, Dir, Max, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

function Damage(hit, damage, cooldown, Color1, Color2, HSound, HPitch)
	for i, v in pairs(hit:GetChildren()) do 
		if v:IsA("Humanoid") and hit.Name ~= Char.Name then
			local find = v:FindFirstChild("Hitz")
			if not find then
				if v.Parent:findFirstChild("Head") then
					local BillG = Create("BillboardGui"){
						Parent = v.Parent.Head,
						Size = UDim2.new(1, 0, 1, 0),
						Adornee = v.Parent.Head,
						StudsOffset = Vector3.new(math.random(-3, 3), math.random(3, 5), math.random(-3, 3)),
					}
					local TL = Create("TextLabel"){
						Parent = BillG,
						Size = UDim2.new(3, 3, 3, 3),
						BackgroundTransparency = 1,
						Text = tostring(damage).."-",
						TextColor3 = Color1.Color,
						TextStrokeColor3 = Color2.Color,
						TextStrokeTransparency = 0,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						FontSize = Enum.FontSize.Size18,
						Font = "ArialBold",
					}
					coroutine.resume(coroutine.create(function()
						wait(1)
						for i = 0, 1, .1 do
							wait(.1)
							BillG.StudsOffset = BillG.StudsOffset + Vector3.new(0, .1, 0)
						end
						BillG:Destroy()
					end))
				end
				
				local bool = Create("BoolValue"){
					Parent = v,
					Name = 'Hitz',
				}
				if HSound ~= nil and HPitch ~= nil then
					CreateSound(HSound, hit, 1, HPitch) 
				end
				game:GetService("Debris"):AddItem(bool, cooldown)
			end
		end
	end
end

function MagnitudeDamage(Part, magni, mindam, maxdam, Color1, Color2, HitSound)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= magni and c.Name ~= Ply.Name then 
					Damage(head.Parent, math.random(mindam, maxdam), 0, Color1, Color2, HitSound, 1)
				end
			end
		end
	end
end

Handle = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 1, "Navy blue", "Handle", Vector3.new(0.216133296, 0.432266444, 0.200000003))
Handleweld = CreateWeld(m, RA, Handle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.03214836, -0.278110504, -0.0978469849, 0, 0.999999702, -2.98023224e-008, 0, -2.98023188e-008, -0.999999821, -1, 4.37113847e-008, -1.77635684e-015))
CreateMesh("BlockMesh", Handle, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.540333092))
FakeHandle = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 1, "Navy blue", "FakeHandle", Vector3.new(0.216133296, 0.432266444, 0.200000003))
FakeHandleweld = CreateWeld(m, Handle, FakeHandle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, 0, 0, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 4.37113812e-008, 4.73655636e-016, 1))
Barrel = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Smoky grey", "Barrel", Vector3.new(0.324199915, 0.200000003, 0.216133296))
Barrelweld = CreateWeld(m, FakeHandle, Barrel, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.000385284424, 5.45991993, 0.648399353, 1.88395493e-016, 1.00281931e-024, -1, 0.999999642, 0, 4.37113812e-008, 0, -0.999999642, -4.73655636e-016))
CreateMesh("CylinderMesh", Barrel, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.567349613, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.324199826, 0.324199826, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.378201485, -0.162090302, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.216133282, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-1.03202057, 0.162498474, 0.864542007, 5.96045453e-008, 0.999996662, 2.34803412e-008, 4.76836078e-007, 6.32193187e-009, 0.999997854, 0.999997139, -2.98022425e-008, -4.3312528e-007))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(1.08066642, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.648406029, -0.594371796, -0.161685944, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.756466568, 0.200000003, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.8910985, -0.70243454, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.200000003, 0.200000003, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.45885229, -0.832115173, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 0.75646615, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(1.40486634, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.810516357, -0.81047821, 0.162475586, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.216133282, 0.324199826, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.37740993, -0.594367981, 0.162475586, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.0540370941, -0.162101746, 0, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 4.37113812e-008, 4.73655636e-016, 1))
CreateMesh("SpecialMesh", Part, Enum.MeshType.FileMesh, "http://www.roblox.com/asset/?id=3270017", Vector3.new(0, 0, 0), Vector3.new(0.369587988, 0.358781129, 0.748901784))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.216133282, 0.200000003, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.37741232, -0.702438354, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0.5, "Really black", "Part", Vector3.new(0.432266563, 0.200000003, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.000377655029, -1.56698084, -1.0320282, -4.17232428e-007, 6.32132613e-009, -0.999997616, -0.999997139, 2.98022425e-008, 2.99015426e-007, -8.70414851e-014, 0.999996722, -2.34809274e-008))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.432266563, 2.48553157, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.000385284424, 3.51209116, 0.648399353, 1.78814986e-007, -6.32150376e-009, -1, 0.999999642, -5.96046341e-008, 2.22526424e-007, -5.96046341e-008, -0.999999642, 6.32149666e-009))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.216133282, 0.200000003, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.37741327, -0.486289978, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.200000003, 0.756466269, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-1.45884228, 0.0540428162, 0.000385284424, 0.999999583, -4.47034729e-008, 4.37113776e-008, 4.47034729e-008, 0.999999583, 2.42770696e-015, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 1, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.324199975, 0.324199826, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000377655029, -1.02661896, -0.162124634, 4.37113812e-008, 4.73655636e-016, 1, 0, 0.999999642, 4.73655636e-016, -0.999999642, 0, -4.37113812e-008))
CreateMesh("SpecialMesh", Part, Enum.MeshType.FileMesh, "http://www.roblox.com/asset/?id=3270017", Vector3.new(0, 0, 0), Vector3.new(0.218294606, 0.239907846, 1.02987504))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(2.485533, 0.216133222, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.02665424, -0.324203491, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(2.16133285, 0.200000003, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.18871307, -0.486282349, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.216133282, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000408172607, 1.19412231, 0.869961739, 4.17229757e-007, 6.32150021e-009, 0.999997854, 8.70414851e-014, -0.999996722, -2.34808173e-008, 0.999997079, 1.49012358e-008, -3.73518958e-007))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.324199975, 0.324199826, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000377655029, -1.02661514, -0.378243446, 4.37113812e-008, 4.73655636e-016, 1, 0, 0.999999642, 4.73655636e-016, -0.999999642, 0, -4.37113812e-008))
CreateMesh("SpecialMesh", Part, Enum.MeshType.FileMesh, "http://www.roblox.com/asset/?id=3270017", Vector3.new(0, 0, 0), Vector3.new(0.229101285, 0.250714511, 2.71571469))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.324199975, 0.324199826, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.000385284424, -1.02661896, 1.56696892, -1.93715053e-007, 9.32587256e-015, -0.999999702, 0, 0.999999642, 4.73655636e-016, 0.999999404, 4.47034836e-008, -6.05967614e-008))
CreateMesh("SpecialMesh", Part, Enum.MeshType.FileMesh, "http://www.roblox.com/asset/?id=3270017", Vector3.new(0, 0, 0), Vector3.new(0.218294606, 0.239907846, 1.02987504))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.200000003, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.0540370941, -0.162101746, 0, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 4.37113812e-008, 4.73655636e-016, 1))
CreateMesh("SpecialMesh", Part, Enum.MeshType.FileMesh, "http://www.roblox.com/asset/?id=3270017", Vector3.new(0, 0, 0), Vector3.new(0.369587988, 0.369587809, 0.748901784))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(1.29679966, 0.200000003, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.864494324, -0.378234863, 0.000385284424, 0.999999583, -4.47034729e-008, 4.37113776e-008, 4.47034729e-008, 0.999999583, 2.42770696e-015, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.200000003, 0.200000003, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.270159721, -0.832111359, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 0.75646615, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(1.08066642, 0.200000003, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.72902441, -0.594367981, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.324199975, 0.324199826, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.000385284424, -1.02661514, 1.35084629, -1.93715053e-007, 9.32587256e-015, -0.999999702, 0, 0.999999642, 4.73655636e-016, 0.999999404, 4.47034836e-008, -6.05967614e-008))
CreateMesh("SpecialMesh", Part, Enum.MeshType.FileMesh, "http://www.roblox.com/asset/?id=3270017", Vector3.new(0, 0, 0), Vector3.new(0.229101285, 0.250714511, 2.71571469))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.432266563, 0.648399651, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000385284424, 0.864570618, -1.03203201, 3.57626845e-007, 6.32133856e-009, 0.999997854, 0.999997139, -2.98022425e-008, -3.1391599e-007, -8.70414851e-014, 0.999996722, 2.34809345e-008))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.216133282, 0.324199826, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.37740993, -0.594367981, -0.161708832, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(1.08066642, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.648406029, -0.594371796, 0.162475586, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.324199975, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.0540428162, -0.486282349, 0.162475586, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.864533126, 0.540332973, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.972568512, -0.0540428162, 0.000385284424, 0.999999583, -4.47034729e-008, 4.37113776e-008, 4.47034729e-008, 0.999999583, 2.42770696e-015, 0, -0, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(1.40486634, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.810501099, -0.810474396, -0.161685944, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0.5, "Really black", "Part", Vector3.new(0.432266563, 0.200000003, 0.216133296))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000385284424, 0.162106514, -1.0320282, 3.57626845e-007, 6.32133856e-009, 0.999997854, 0.999997139, -2.98022425e-008, -3.1391599e-007, -8.70414851e-014, 0.999996722, 2.34809345e-008))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.216134712, 0.216134697, 0.216134712))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000408172607, 0.864553452, -1.03203201, 3.57626561e-007, 6.59261232e-008, 1, 0.999999642, 0, -3.1391528e-007, 0, 0.999999642, -6.59261374e-008))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(1.40486634, 0.200000003, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.810516357, -0.70243454, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.324199975, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.0540428162, -0.486282349, -0.161685944, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.324199915, 0.756466269, 0.432266533))
Partweld = CreateWeld(m, FakeHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.000385284424, 5.1330142, 0.648399353, 0, 0, -1, 0.999999642, 0, 4.37113812e-008, 0, -0.999999642, -4.73655636e-016))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.432266563, 0.216133222, 0.864533186))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000385284424, -0.324199677, -0.972576141, 2.98023117e-008, 0, 0.999999702, 0, -0.999999642, -4.73655636e-016, 0.999999285, 1.49011701e-008, 1.3909041e-008))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Wedge", Vector3.new(0.200000003, 0.432266444, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.161708832, -0.648399353, -2.86102295e-005, 0, -0, 1, 0, 0.999999642, 4.73655636e-016, -0.999999642, 0, -4.37113812e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 1, 1))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.432266563, 0.216133192, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000385284424, -0.108055115, -0.432257652, 2.98023117e-008, 0, 0.999999702, 0, -0.999999642, -4.73655636e-016, 0.999999285, 1.49011701e-008, 1.3909041e-008))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Wedge", Vector3.new(0.200000003, 0.200000003, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.162475586, -0.486286163, 0.32416153, 0, -0, 1, 0, 0.999999642, 4.73655636e-016, -0.999999642, 0, -4.37113812e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 0.540332973, 1))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.200000003, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.161708832, -0.810497284, 1.62095213, 1.49011559e-008, 0, -0.999999762, 0, 0.999999642, 4.73655636e-016, 0.999999404, 4.47034836e-008, 5.86125317e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 0.540332973, 1))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Wedge", Vector3.new(0.200000003, 0.432266384, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.162475586, -0.648399353, -2.86102295e-005, 0, -0, 1, 0, 0.999999642, 4.73655636e-016, -0.999999642, 0, -4.37113812e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 1, 1))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.200000003, 0.200000003, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.162475586, -0.810497284, 1.62095213, 1.49011559e-008, 0, -0.999999762, 0, 0.999999642, 4.73655636e-016, 0.999999404, 4.47034836e-008, 5.86125317e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 0.540332973, 1))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.432266563, 0.216133237, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000385284424, 0.324203491, 2.37740946, 1.06338617e-018, 5.01342412e-010, 0.999999404, 1.49011701e-008, -0.999999285, 5.01343078e-010, 0.999999285, 1.49011701e-008, 4.37113634e-008))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Wedge", Vector3.new(0.432266563, 0.216133222, 0.216133296))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.000385284424, 0.108070374, -0.108057022, 2.98023117e-008, 0, 0.999999702, 0, -0.999999642, -4.73655636e-016, 0.999999285, 1.49011701e-008, 1.3909041e-008))
Wedge = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Wedge", Vector3.new(0.200000003, 0.200000003, 0.216133267))
Wedgeweld = CreateWeld(m, FakeHandle, Wedge, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.161708832, -0.486286163, 0.32416153, 0, -0, 1, 0, 0.999999642, 4.73655636e-016, -0.999999642, 0, -4.37113812e-008))
CreateMesh("SpecialMesh", Wedge, Enum.MeshType.Wedge, "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 0.540332973, 1))
MagHandle = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "MagHandle", Vector3.new(0.432266504, 0.324199826, 0.216133296))
MagHandleweld = CreateWeld(m, FakeHandle, MagHandle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.648423195, -0.0540428162, 0.000385284424, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 0, -0, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.200000003, 0.324199826, 0.216133296))
Partweld = CreateWeld(m, MagHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-0.270163536, 0, 0, 0.999999642, 0, 0, 0, 0.999999642, -0, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 1, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.200000003, 0.324199826, 0.216133296))
Partweld = CreateWeld(m, MagHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.270174026, 0, 0, 0.999999642, 0, 0, 0, 0.999999642, -0, 0, -0, 1))
CreateMesh("BlockMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(0.540333211, 1, 1))
BoltHandle = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "BoltHandle", Vector3.new(0.216133282, 1.40486586, 0.216133267))
BoltHandleweld = CreateWeld(m, FakeHandle, BoltHandle, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.540328979, -0.486276627, -0.000385284424, -4.47034729e-008, -0.999999583, -2.42770696e-015, -0.999999642, 0, -4.37113812e-008, 0, 0, -0.99999994))
CreateMesh("CylinderMesh", BoltHandle, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.216133282, 0.216133252, 0.216133267))
Partweld = CreateWeld(m, BoltHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0, 0.70238018, 0, 0.999999523, 4.47034729e-008, 0, 4.47034729e-008, 0.999999642, 0, 0, 0, 0.999999881))
CreateMesh("SpecialMesh", Part, Enum.MeshType.Sphere, "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 1))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Really black", "Part", Vector3.new(0.324199915, 0.324199826, 0.200000003))
Partweld = CreateWeld(m, BoltHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.015832901, 0.146270752, 0.648381233, 0.707106292, 5.08757338e-008, 0.707106531, 0.707106411, -8.72889849e-009, -0.707106411, 8.94069458e-008, 0.999999404, -5.09424458e-009))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 1, 0.540333092))
Part = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 0, "Navy blue", "Part", Vector3.new(0.324199915, 0.200000003, 0.200000003))
Partweld = CreateWeld(m, BoltHandle, Part, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(0.0158443451, 0.362377167, 0.648385048, 0.707106292, 5.08757338e-008, 0.707106531, 0.707106411, -8.72889849e-009, -0.707106411, 8.94069458e-008, 0.999999404, -5.09424458e-009))
CreateMesh("CylinderMesh", Part, "", "", Vector3.new(0, 0, 0), Vector3.new(1, 0.540332973, 0.540333092))
ScopeZoom = CreatePart(Enum.FormFactor.Custom, m, Enum.Material.SmoothPlastic, 0, 1, "Bright violet", "ScopeZoom", Vector3.new(0.216133296, 0.200000003, 0.200000003))
ScopeZoomweld = CreateWeld(m, FakeHandle, ScopeZoom, CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(1.72752714, -1.03763962, 0, 0.999999642, 0, 4.37113812e-008, 0, 0.999999642, 4.73655636e-016, 4.37113812e-008, 4.73655636e-016, 1))

local PE1 = Create("ParticleEmitter"){
	Parent = Barrel,
	Color = ColorSequence.new(BrickColor.new("Dark stone grey").Color),
	Transparency = NumberSequence.new(0),
	Size = NumberSequence.new(.5),
	Texture = "rbxassetid://257430870",
	Lifetime = NumberRange.new(.1),
	Rate = 100,
	VelocitySpread = 180,
	Rotation = NumberRange.new(0),
	Speed = NumberRange.new(0),
	LightEmission = .6,
	LockedToPart = true,
	Enabled = false
}

local PE2 = PE1:Clone()
PE2.Size = NumberSequence.new(.7)
PE2.LightEmission = 1
PE2.Texture = "rbxassetid://87729590"

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new(0.2, 0.2, 0.2))
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 2)
	Effects[#Effects + 1] = {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3
	}
end

local Ammo = 10
local Depleted = false

function Shoot(asd, spread1, spread2)
	local MainPos = asd.Position
	local MainPos2 = mouse.Hit.p
	local spread = Vector3.new((math.random(-spread1, 0) + math.random()) * spread2, (math.random(-spread1, 0) + math.random()) * spread2, (math.random(-spread1, 0) + math.random()) * spread2) * (asd.Position - mouse.Hit.p).magnitude / 100
	local MouseLook = CFrame.new((MainPos + MainPos2) / 2, MainPos2 + spread)
	num = 30
	Ammo = Ammo - 1
	print(Ammo)
	if Ammo == 0 then
		Depleted = true
	end
	coroutine.resume(coroutine.create(function(Spreaded) 
		repeat
			wait()
			local hit, pos = rayCast(MainPos, MouseLook.lookVector, 50, RP.Parent)
			local TheHit = mouse.Hit.p
			local mag = (MainPos - pos).magnitude 
			CylinderEffect(BrickColor.new("Dark stone grey"), CFrame.new((MainPos + pos) / 2, pos) * CFrame.Angles(1.57, 0, 0), 3, mag * 5, 3, .5, 1, .5, 0.2)
			MainPos = MainPos + (MouseLook.lookVector * 50)
			num = num - 1
			if hit ~= nil then
				num = 0
				local ref = CreatePart(3, workspace, "Neon", 0, 1, BrickColor.new("Dark stone grey"), "Reference", Vector3.new())
				ref.Anchored = true
				ref.CFrame = CFrame.new(pos)
				MagnitudeDamage(ref, 5, 999999999, 999999999, BrickColor.new("Dark stone grey"), BrickColor.new("Navy blue") , "rbxassetid://199149297")
				game:GetService("Debris"):AddItem(ref, 1) 
			end
		until num <= 0
	end))
end
local Aiming = false
gyro = Instance.new("BodyGyro")
gyro.Parent = nil
gyro.P = 1e7
gyro.D = 1e3
gyro.MaxTorque = Vector3.new(0,1e7,0)


local Crouching = false

function Fire()
	if Aiming == true then
		attack = true
		CreateSound("rbxassetid://132572951", Barrel, 1, .9)
		CreateSound("rbxassetid://130767489", Barrel, .7, 1.2)
		PE1.Enabled = true
		PE2.Enabled = true
		Shoot(Barrel, 0, 0)
		for i = 0, 1, 0.2 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(-10), math.rad(90)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(.5, 0.5, -.6) * CFrame.Angles(math.rad(90), math.rad(-20), math.rad(-90)), .5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.7, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(140)), .5)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		end
		PE1.Enabled = false
		PE2.Enabled = false
		for i = 0, 1, 0.1 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(90)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(.5, 0.5, -.6) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-90)), .3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(90)), .3)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		end
		Handleweld.Part0 = LA
		Handleweld.C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		Handleweld.C1 = CFrame.new(-0.737663269, -0.281144857, 0.33117196, 0.00916702952, 0.939647615, 0.342020333, 0.999940991, -0.0106014106, 0.00232372736, 0.00580918044, 0.341978878, -0.939689875)
		for i = 0, 1, 0.1 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(80)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(.5, 0.5, -.6) * CFrame.Angles(math.rad(80), math.rad(-30), math.rad(-90)), .3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(70)), .3)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		end
		CreateSound("rbxassetid://146740582", BoltHandle, .7, 1)
		for i = 0, 1, 0.1 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(80)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.6) * CFrame.Angles(math.rad(80), math.rad(-30), math.rad(-90)), .5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(70)), .3)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			BoltHandleweld.C0 = clerp(BoltHandleweld.C0, CFrame.new(.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
		end
		for i = 0, 1, 0.1 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(80)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(.5, 0.5, -.6) * CFrame.Angles(math.rad(80), math.rad(-30), math.rad(-90)), .5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(70)), .3)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			BoltHandleweld.C0 = clerp(BoltHandleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
		end
		for i = 0, 1, 0.3 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(90)), .4)
			RW.C0 = clerp(RW.C0, CFrame.new(.51, 0.51, -.6) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-90)), .4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.51, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(90)), .4)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
		end
		Handleweld.Part0 = RA
		Handleweld.C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		Handleweld.C1 = CFrame.new(1.03214836, -0.278110504, -0.0978469849, 0, 0.999999702, -2.98023224e-008, 0, -2.98023188e-008, -0.999999821, -1, 4.37113847e-008, -1.77635684e-015)
		attack = false
	end
end

local Zoomed = false

function Reload()
	attack = true
	for i = 0, 1, 0.1 do
		wait()
		if Crouching == false and Aiming == true then 
			RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
		elseif Crouching == true and Aiming == true then 
			RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
		end
		Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(0), math.rad(0), math.rad(50)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.5) * CFrame.Angles(math.rad(120), math.rad(0), math.rad(-50)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.5, -.5) * CFrame.Angles(math.rad(0), math.rad(60), math.rad(120)), .3)
		if Crouching == false and Aiming == true then
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
		elseif Crouching == true and Aiming == true then
			RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
		end
		FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
	end
	CreateSound("rbxassetid://131045401", FakeHandle, 1, 1)
	MagHandleweld.Part0 = LA
	MagHandleweld.C0 = CFrame.new(.5, -1, .6) * CFrame.Angles(1.5, 0, 1.5)
	for i = 0, 1, 0.08 do
		wait()
		if Crouching == false and Aiming == true then 
			RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
		elseif Crouching == true and Aiming == true then 
			RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
		end
		Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(5), math.rad(50)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.5) * CFrame.Angles(math.rad(120), math.rad(0), math.rad(-50)), .3)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.5, -.3) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(20)), .3)
		if Crouching == false and Aiming == true then
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
		elseif Crouching == true and Aiming == true then
			RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
		end
		FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
	end
	CreateSound("rbxassetid://131045429", FakeHandle, 1, 1)
	for i = 0, 1, 0.08 do
		wait()
		if Crouching == false and Aiming == true then 
			RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
		elseif Crouching == true and Aiming == true then 
			RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
		end
		Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(0), math.rad(0), math.rad(50)), .3)
		RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.5) * CFrame.Angles(math.rad(100), math.rad(0), math.rad(-50)), .5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.5, -.3) * CFrame.Angles(math.rad(0), math.rad(60), math.rad(100)), .5)
		if Crouching == false and Aiming == true then
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
		elseif Crouching == true and Aiming == true then
			RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
		end
		FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
	end
	MagHandleweld.Part0 = FakeHandle
	MagHandleweld.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
	Ammo = 10
	print(Ammo)
	if Depleted == true then
		Depleted = false
		Handleweld.Part0 = LA
		Handleweld.C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		Handleweld.C1 = CFrame.new(-0.737663269, -0.281144857, 0.33117196, 0.00916702952, 0.939647615, 0.342020333, 0.999940991, -0.0106014106, 0.00232372736, 0.00580918044, 0.341978878, -0.939689875)
		for i = 0, 1, 0.1 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(80)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(.5, 0.5, -.6) * CFrame.Angles(math.rad(80), math.rad(-30), math.rad(-90)), .3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(70)), .3)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
		end
		CreateSound("rbxassetid://146740582", BoltHandle, .7, 1)
		for i = 0, 1, 0.1 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(80)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(1, 0.5, -.6) * CFrame.Angles(math.rad(80), math.rad(-30), math.rad(-90)), .5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(70)), .3)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			BoltHandleweld.C0 = clerp(BoltHandleweld.C0, CFrame.new(.5, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
		end
		for i = 0, 1, 0.3 do
			wait()
			if Crouching == false and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			elseif Crouching == true and Aiming == true then 
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
			end
			Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(80)), .3)
			RW.C0 = clerp(RW.C0, CFrame.new(.5, 0.5, -.6) * CFrame.Angles(math.rad(80), math.rad(-30), math.rad(-90)), .5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1, 0.3, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(70)), .3)
			if Crouching == false and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
			elseif Crouching == true and Aiming == true then
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
			end
			FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
			BoltHandleweld.C0 = clerp(BoltHandleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
		end
	end
	Handleweld.Part0 = RA
	Handleweld.C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	Handleweld.C1 = CFrame.new(1.03214836, -0.278110504, -0.0978469849, 0, 0.999999702, -2.98023224e-008, 0, -2.98023188e-008, -0.999999821, -1, 4.37113847e-008, -1.77635684e-015)
	attack = false
end

mouse.Button1Down:connect(function()
	if attack == false and Depleted == false then
		Fire()
	end
end)

mouse.KeyDown:connect(function(k)
	k = k:lower()
	if k == "r" and attack == false then
		Reload()
	elseif k == "f" and Aiming == false then
		Aiming = true
	elseif k == "f" and Aiming == true then
		Aiming = false
	elseif k == "c" and Aiming == true and Crouching == false then
		Crouching = true
	elseif k == "c" and Aiming == true and Crouching == true then
		Crouching = false
	elseif k == "z" and Aiming == true and Zoomed == false then
		Zoomed = true
		CreateSound("rbxassetid://180144779", FakeHandle, 1, 1)
		for i = 0, 1, 0.2 do 
			wait()
			cam.FieldOfView = cam.FieldOfView - 5
		end
		Ply.CameraMode = "LockFirstPerson"
		--Ply.DevEnableMouseLock = false
		cam.FieldOfView = 10
		cam.CameraSubject = ScopeZoom
		mouse.Icon = "rbxassetid://18006519"
	elseif k == "z" and Aiming == true and Zoomed == true then
		Zoomed = false
		CreateSound("rbxassetid://190623951", FakeHandle, 1, 1)
		for i = 0, 1, 0.2 do 
			wait()
			cam.FieldOfView = cam.FieldOfView + 5
		end
		Ply.CameraMode = "Classic"
		--Ply.DevEnableMouseLock = true
		cam.FieldOfView = 80
		cam.CameraSubject = Hu
		mouse.Icon = ""
	end
end)


local sine = 0
local change = 1
local val = 0

while true do
	wait()
	sine = sine + change
	local torvel = (RP.Velocity * Vector3.new(1, 0, 1)).magnitude 
	local velderp = RP.Velocity.y
	hitfloor, posfloor = rayCast(RP.Position, (CFrame.new(RP.Position, RP.Position - Vector3.new(0, 1, 0))).lookVector, 4, Char)
	if equipped == true or equipped == false then
		if Aiming == true then
			if Crouching == false and Aiming == true then
				Hu.WalkSpeed = 10
			elseif Crouching == true and Aiming == true then
				Hu.WalkSpeed = 5
			end
			gyro.Parent = RP
			local gunpos = Vector3.new(mouse.Hit.p.x, He.Position.Y, mouse.Hit.p.z)
			offset = (Tor.Position.y - mouse.Hit.p.y) / 60
			local mag = (Tor.Position - mouse.Hit.p).magnitude / 80
			offset = offset / mag 
			gyro.CFrame = CFrame.new(Vector3.new(),(mouse.Hit.p -RP.CFrame.p).unit * 100)
		elseif Aiming == false then
			Hu.JumpPower = 50
			Hu.WalkSpeed = 16
			gyro.Parent = nil
		end
		if RP.Velocity.y > 1 and hitfloor == nil then 
			Anim = "Jump"
			if attack == false and Aiming == false then
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.4, -.2) * CFrame.Angles(math.rad(60), math.rad(0), math.rad(-40)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.4) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(60)), .3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(-30)), .3)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(30)), .3)
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(0)), .3)
			elseif attack == false and Aiming == true then
				if Crouching == false and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				elseif Crouching == true and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				end
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(90)), .4)
				RW.C0 = clerp(RW.C0, CFrame.new(.51, 0.51, -.6) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-90)), .4)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.51, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(90)), .4)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				if Crouching == false and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				elseif Crouching == true and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
				end
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
			end
		elseif RP.Velocity.y < -1 and hitfloor == nil then 
			Anim = "Fall"
			if attack == false and Aiming == false then
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.4, -.2) * CFrame.Angles(math.rad(100), math.rad(0), math.rad(-40)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.4) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(100)), .3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(30)), .3)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-4), math.rad(0), math.rad(-30)), .3)
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(0)), .3)
			elseif attack == false and Aiming == true then
				if Crouching == false and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				elseif Crouching == true and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				end
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(90)), .4)
				RW.C0 = clerp(RW.C0, CFrame.new(.51, 0.51, -.6) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-90)), .4)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.51, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(90)), .4)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				if Crouching == false and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				elseif Crouching == true and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
				end
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			if attack == false and Aiming == false then
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(50)), .3)
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(-50)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.4, 0) * CFrame.Angles(math.rad(70), math.rad(0), math.rad(-40)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.4) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(70)), .3)
				RH.C0 = clerp(RH.C0, CFrame.new(.9, -.5, .2) * RHCF * CFrame.Angles(math.rad(-5), math.rad(-50), math.rad(0)), .3)
				LH.C0 = clerp(LH.C0, CFrame.new(-.5, -1, -1) * LHCF * CFrame.Angles(math.rad(-5), math.rad(-50), math.rad(50)), .3)
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(70), math.rad(0)), .3)
			elseif attack == false and Aiming == true then
				if Crouching == false and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				elseif Crouching == true and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				end
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(90)), .4)
				RW.C0 = clerp(RW.C0, CFrame.new(.51, 0.51, -.6) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-90)), .4)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.51, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(90)), .4)
				if Crouching == false and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				elseif Crouching == true and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.5, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
				end
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
			end
		elseif torvel > 2 and hitfloor ~= nil then
			Anim = "Walk"
			if attack == false and Aiming == false then
				RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)), .3)
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), .3)
				RW.C0 = clerp(RW.C0, CFrame.new(1.2, 0.4, -.2) * CFrame.Angles(math.rad(50), math.rad(0), math.rad(-40)), .3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.5, -.4) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(50)), .3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(0)), .3)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(0)), .3)
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(80), math.rad(0)), .3)
			elseif attack == false and Aiming == true then
				if Crouching == false and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				elseif Crouching == true and Aiming == true then 
					RJ.C0 = clerp(RJ.C0, RootCF * CFrame.new(0, 0, -.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), .4)
				end
				Ne.C0 = clerp(Ne.C0, NeckCF * CFrame.Angles(math.rad(5), math.rad(0), math.rad(90)), .4)
				RW.C0 = clerp(RW.C0, CFrame.new(.51, 0.51, -.6) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-90)), .4)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.51, 0) * CFrame.Angles(math.rad(0), math.rad(160), math.rad(90)), .4)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				if Crouching == false and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
				elseif Crouching == true and Aiming == true then
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.1, -.5) * RHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(0)), .4)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -.1, -.2) * LHCF * CFrame.Angles(math.rad(-5), math.rad(0), math.rad(50)), .4)
				end
				FakeHandleweld.C0 = clerp(Handleweld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .4)
			end
		end

	end
	if #Effects > 0 then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if Thing[1].Transparency <= 1 then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, .5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
end

local function starmeowz()
local rightarm = {"RARM";"International Fedora"}
local leftarm = {"LARM";"Robloxclassicred"}
local rightleg = {"MeshPartAccessory";"RCap"}
local leftleg = {"Unloaded head";"RunningBull"}
local torso = {"Black";"MediHood";"Accessory (White Torso)"}
game.Players.LocalPlayer.Character.Archivable = true
local fakechar = game.Players.LocalPlayer.Character:Clone()
fakechar.Parent = game.Workspace
for i,v in pairs(fakechar:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end
fakechar.Head.face.Transparency = 1
game.Players.LocalPlayer.Character.Parent = fakechar
local realchar = fakechar[game.Players.LocalPlayer.Name]
for i,v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do if v:IsA("Tool") then v.Parent = game.Players.LocalPlayer.Character end end
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
fakechar.Animate.Disabled = true
fakechar.Animate.Enabled = true
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CFrame = fakechar["HumanoidRootPart"].CFrame end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CanCollide = false end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.AssemblyAngularVelocity = Vector3.new(6400,6400,6400) end end
		task.wait()
	end
end)
game.Players.LocalPlayer.CharacterAdded:Connect(function()
task.wait(.1)
game.Players.LocalPlayer.Character.Parent = fakechar
realchar = fakechar[game.Players.LocalPlayer.Name]
for i,v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do if v:IsA("Tool") then v.Parent = game.Players.LocalPlayer.Character end end
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
realchar:BreakJoints()
task.wait(1)
spawn(function()
	while true do
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) then v.Handle.CFrame = fakechar["Right Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftarm,v.Name) then v.Handle.CFrame = fakechar["Left Arm"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightleg,v.Name) then v.Handle.CFrame = fakechar["Right Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(leftleg,v.Name) then v.Handle.CFrame = fakechar["Left Leg"].CFrame * CFrame.Angles(0,0,1.57) end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(torso,v.Name) then v.Handle.CFrame = fakechar["Torso"].CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(rightarm,v.Name) or table.find(leftarm,v.Name) or table.find(rightleg,v.Name) or table.find(leftleg,v.Name) or table.find(torso,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CFrame = fakechar["HumanoidRootPart"].CFrame end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.CanCollide = false end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Tool") then v.Handle.AssemblyAngularVelocity = Vector3.new(6400,6400,6400) end end
		task.wait()
	end
end)
end)
game.Players.LocalPlayer.SimulationRadius = 9999

-- put scripts under here! --
-- Created by Nebula_Zorua --
-- NebulaGlitcher Demo --
-- The official second Glitcher's Demo --
-- Discord: Nebula the Zorua#6969
-- Youtube: https://www.youtube.com/channel/UCo9oU9dCw8jnuVLuy4_SATA

wait(0.2)

--Values (EDITED)

local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local char = plr.Character
local tor = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")

local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local WALKINGANIM = false
local WALK = 0
local VALUE1 = false
local VALUE2 = false

local ATTACK = false

function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
	HOLD = false
end

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end

function createaccessory(attachmentpart,mesh,texture,scale,offset,color)
	local acs = Instance.new("Part")
	acs.CanCollide = false
	acs.Anchored = false
	acs.Size = Vector3.new(0,0,0)
	acs.CFrame = attachmentpart.CFrame
	acs.Parent = Character
	acs.BrickColor = color
	local meshs = Instance.new("SpecialMesh")
	meshs.MeshId = mesh
	meshs.TextureId = texture
	meshs.Parent = acs
	meshs.Scale = scale
	meshs.Offset = offset
	weldBetween(attachmentpart,acs)
end

function createbodypart(TYPE,COLOR,PART,OFFSET,SIZE)
	if TYPE == "Gem" then
		local acs = CreatePart(3, Character, "Plastic", 0, 0, COLOR, "Part", VT(0,0,0))
		acs.Anchored = false
		acs.CanCollide = false
		acs.CFrame = PART.CFrame
		local acs2 = CreateMesh("SpecialMesh", acs, "FileMesh", "9756362", "", SIZE, OFFSET)
		weldBetween(PART,acs)
	elseif TYPE == "Skull" then
		local acs = CreatePart(3, Character, "Plastic", 0, 0, COLOR, "Part", VT(0,0,0))
		acs.Anchored = false
		acs.CanCollide = false
		acs.CFrame = PART.CFrame
		local acs2 = CreateMesh("SpecialMesh", acs, "FileMesh", "4770583", "", SIZE, OFFSET)
		weldBetween(PART,acs)
	elseif TYPE == "Eye" then
		local acs = CreatePart(3, Character, "Neon", 0, 0, COLOR, "Part", VT(0,0,0))
		acs.Anchored = false
		acs.CanCollide = false
		acs.CFrame = PART.CFrame
		local acs2 = CreateMesh("SpecialMesh", acs, "Sphere", "", "", SIZE, OFFSET)
		weldBetween(PART,acs)
	end
end


function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	elseif TYPE == "Head" then
		local MSH = IT("SpecialMesh",PART)
		MSH.Scale = VT(1.25,1.25,1.25)
	end
end


function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]


Class_Name = "Void Face"

Player_Size = 1 --Size of the player.
Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)

local Speed = 16
local Effects2 = {}

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

--End of Values

--// Shortcut Variables \\--
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local UIS = S.UserInputService
local CAS = S.ContextActionService
--// Initializing \\--
local Plr = Plrs.LocalPlayer
local Char = Plr.Character
local Hum = Char:FindFirstChildOfClass'Humanoid'
local RArm = Char["Right Arm"]
local LArm = Char["Left Arm"]
local RLeg = Char["Right Leg"]
local LLeg = Char["Left Leg"]	
local Root = Char:FindFirstChild'HumanoidRootPart'
local Torso = Char.Torso
local Head = Char.Head
local NeutralAnims = true
local Attack = false
local Debounces = {Debounces={}}
local Mouse = Plr:GetMouse()
local Hit = {}
local Sine = 0
local Change = 1
local PlrGui = Plr:FindFirstChildOfClass'PlayerGui'
local Hue = 0;
local Combo = 1
local BloodPuddles = {}

local DontAttackPlayers = false

local BurnInterval = .7

local Radioactive = {}

local Hits = 0;
local HitTime = time()

local MaxHits = 60;

local Effects = IN("Folder",Char)
Effects.Name = "Effects"

--Invencible Script by 1x1x1x1IAMbck or Shackluster!:

function AoEDamage(position,radius,min,max,maxstrength,beserk,critrate,critmultiplier,CanBeDodgedByJumping,DoesWarp,Instakill,HasChain)

	local dmg = math.random(min,max)
	for i,v in ipairs(workspace:GetChildren()) do
		if v:FindFirstChild("HitBy"..Player.Name) == nil then
			local body = v:GetChildren()
			for part = 1, #body do
				if(v:FindFirstChild("HitBy"..Player.Name) == nil and (body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
					if(body[part].Position - position).Magnitude < radius then
						if v.ClassName == "Model" then
							if v:FindFirstChildOfClass("Humanoid") then
								local HUMAN = v:FindFirstChildOfClass("Humanoid")
								if HUMAN.Health ~= 0 then
									if HasChain == true then
										local defence = Instance.new("BoolValue",v)
										defence.Name = ("HitBy"..Player.Name)
										game:GetService("Debris"):AddItem(defence, 1)
										coroutine.resume(coroutine.create(function()
											local TORSO = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
											if TORSO then
												local PART = IT("Part",Effects)
												PART.Anchored = true
												PART.CanCollide = false
												PART.Transparency = 1
												PART.CFrame = CF(position)
												Debris:AddItem(PART,15)
												local A = IT("Attachment",PART)
												--TORSO.Anchored = true
												local Front = CreatePart(3, Effects, "Neon", 1, 1, "Really black", "Chain head", VT(1,1,1),false)
												Front.CFrame = CF(position)
												Front.CanCollide = true
												CreateSound(HITWEAPONSOUNDS[MRANDOM(1,#HITWEAPONSOUNDS)], Front, 10, 1)
												local B = IT("Attachment",Front)
												local ChainLink = IT("Beam",Effects)
												ChainLink.Texture = "rbxassetid://1262544869"
												ChainLink.TextureSpeed = 0
												ChainLink.FaceCamera = true
												ChainLink.Width0 = 3
												ChainLink.Attachment0 = A
												ChainLink.Attachment1 = B
												ChainLink.TextureMode = "Static"
												local bv = Instance.new("BodyVelocity") 
												bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
												bv.velocity = CF(Front.Position,TORSO.Position).lookVector*500
												bv.Parent = Front
												bv.Name = "MOVE"
												coroutine.resume(coroutine.create(function()
													Swait(30)
													bv:remove()
													local POS = Front.Position
													Front.CanCollide = false
													local onefourth = POS:Lerp(position, 0.25) + Vector3.new(0,0,0)
													local threefourths = POS:Lerp(position, 0.75) + Vector3.new(0,0,0)
													for i = 0, 1, 0.07 do
														Swait()
														Front.CFrame = CFrame.new(newBezier(POS, onefourth, threefourths, position, i))
													end
													Front:remove()
													ChainLink:remove()
												end))
												local harm = Front.Touched:Connect(function(hit)
													impale(Front,hit)
												end)
											end
										end))
									elseif DoesWarp == true then
										local defence = Instance.new("BoolValue",v)
										defence.Name = ("HitBy"..Player.Name)
										game:GetService("Debris"):AddItem(defence, 0.001)
										local TORSO = v:FindFirstChild("HumanoidRootPart") or v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
										Warp(TORSO,Instakill)
									else
										if CanBeDodgedByJumping == true then
											if body[part].Position.Y < position.Y+5 then
												if math.random(1,100) < critrate+1 then
													  
													StatLabel("Normal", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), "CRIT/"..dmg , C3(255/255, 0, 0))
												else
													 
													StatLabel("Normal", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), dmg, C3(0, 0, 0))
												end
												local defence = Instance.new("BoolValue",v)
												defence.Name = ("HitBy"..Player.Name)
												game:GetService("Debris"):AddItem(defence, 0.01)
											end
										else
											if beserk == true then
												
											end
											if math.random(1,100) < critrate+1 then
												  
												StatLabel("Normal", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), "CRIT/"..dmg , C3(255/255, 0, 0))
											else
												 
												StatLabel("Normal", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), dmg, C3(0, 0, 0))
											end
											local defence = Instance.new("BoolValue",v)
											defence.Name = ("HitBy"..Player.Name)
											game:GetService("Debris"):AddItem(defence, 0.01)
											Humanoid.Died:connect(function()
												ATTACK = true
											end)

										end
									end
								end
							end
						end
						--body[part].Velocity = CFrame.new(position,body[part].Position).lookVector*5*maxstrength
					end
				end
			end
			if v.ClassName == "Part" then
				if v.Anchored == false and (v.Position - position).Magnitude < radius then
					v.Velocity = CFrame.new(position,v.Position).lookVector*5*maxstrength
				end
			end
		end
	end
end

function Warp(Victim,WarpToVoid)
	Victim.Anchored = true
	coroutine.resume(coroutine.create(function()
		local GUI,GUI2 = CreateGUICircle(Victim)
		CreateSound("1208650519", Victim, 10, 1)
		for i = 1, 100 do
			Swait()
			GUI.Size = GUI.Size + UDim2.new(0.2,0,0.2,0)
			GUI2.Rotation = GUI2.Rotation + 4
		end
		CastWarpOutlines(Victim.Parent)
		if WarpToVoid == false then
			Victim.CFrame = Victim.CFrame * CF(MRANDOM(-65,65),0,MRANDOM(-65,65))
			CreateSound("1177785010", Victim, 10, 1)
			local HUMANOID = Victim.Parent:FindFirstChildOfClass("Humanoid")
			if HUMANOID ~= nil then
				local dmg = MRANDOM(75,95)
				 
				StatLabel("Normal", Victim.CFrame * CF(0, 0 + (Victim.Size.z - 1), 0), "WARPED/"..dmg, C3(0.3, 0, 0.3))
			end
			for i = 1, 50 do
				Swait()
				GUI.Size = GUI.Size - UDim2.new(0.4,0,0.4,0)
				GUI2.Rotation = GUI2.Rotation - 8
			end
			Victim.Anchored = false
			GUI:remove()
		elseif WarpToVoid == true then
			CastWarpOutlines(Victim.Parent)
			q = Victim.Parent:GetChildren()
			for i = 1, #q do
				if q[i] ~= Victim then
					q[i]:remove()
				end
			end
			CreateSound("1177785010", Victim, 10, 1)
			Victim.Transparency = 1
			for i = 1, 50 do
				Swait()
				GUI.Size = GUI.Size - UDim2.new(0.4,0,0.4,0)
				GUI2.Rotation = GUI2.Rotation - 8
			end
			Victim.Parent:remove()
		end
	end))
end

function killnearest(position,range,maxstrength)
	for i,v in ipairs(workspace:GetChildren()) do
		local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						v:BreakJoints()
					end
					--table.insert(Effects2,{body[part],"Disappear",0.02,2,2,2,2})
					body[part].Velocity = CFrame.new(position,body[part].Position).lookVector*5*maxstrength
				end
			end
		end
		if v.ClassName == "Part" then
			if v.Anchored == false and (v.Position - position).Magnitude < range then
				--table.insert(Effects2,{v,"Disappear",0.02,2,2,2,2})
				v.Velocity = CFrame.new(position,v.Position).lookVector*5*maxstrength
			end
		end
	end
end
--End of Ivencible script..


--// Output Stuff \\--

function Output(type,...)
	print(table.concat{...,"\t"})
end

warn("NEBULAGLITCHER DEMO (EDITED BY FENIX7667 (Imortal edit)")
warn("CONTROLS:")
warn("SOLITUDE - Z, T")
warn("THE BIG BLACK - Z (NOT FINISHED)")
warn("CLARITY - Z")
warn("GLITCHY - Z")
warn("STRESS - Z")
warn("JUSTICE - Z")

warn("The real NebulaGlitcher has more modes, and a combo system. This is just a demo.")

--// Debounce System \\--

function Debounces:New(name,cooldown)
	local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
	setmetatable(aaaaa,{__index = Debounces})
	Debounces.Debounces[name] = aaaaa
	return aaaaa
end

function Debounces:Use(overrideUsable)
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.Usable or overrideUsable)then
		self.Usable = false
		self.CoolingDown = true
		local LastUse = time()
		self.LastUse = LastUse
		delay(self.Cooldown or 2,function()
			if(self.LastUse == LastUse)then
				self.CoolingDown = false
				self.Usable = true
			end
		end)
	end
end

function Debounces:Get(name)
	assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
	for i,v in next, Debounces.Debounces do
		if(i == name)then
			return v;
		end
	end
end

function Debounces:GetProgressPercentage()
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.CoolingDown and not self.Usable)then
		return math.max(
			math.floor(
				(
					(time()-self.LastUse)/self.Cooldown or 2
				)*100
			)
		)
	else
		return 100
	end
end

--// Instance Creation Functions \\--

function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or Torso
	return Sound
end
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent or Char
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function Clone(instance,parent,properties)
	local inst = instance:Clone()
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound,soundPart
end


--// Extended ROBLOX tables \\--
local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})
--// Require stuff \\--
function CamShake(who,times,intense,origin) 
	coroutine.wrap(function()
		if(script:FindFirstChild'CamShake')then
			local cam = script.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = intense
			cam:WaitForChild'times'.Value = times

			if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
			cam.Parent = who
			wait()
			cam.Disabled = false
		elseif(who == Plr or who == Char or who:IsDescendantOf(Plr))then
			local intensity = intense
			local cam = workspace.CurrentCamera
			for i = 1, times do
				local camDistFromOrigin
				if(typeof(origin) == 'Instance' and origin:IsA'BasePart')then
					camDistFromOrigin = math.floor( (cam.CFrame.p-origin.Position).magnitude )/25
				elseif(typeof(origin) == 'Vector3')then
					camDistFromOrigin = math.floor( (cam.CFrame.p-origin).magnitude )/25
				end
				if(camDistFromOrigin)then
					intensity = math.min(intense, math.floor(intense/camDistFromOrigin))
				end
				cam.CFrame = cam.CFrame:lerp(cam.CFrame*CFrame.new(math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100)*CFrame.Angles(math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100)),.4)
				swait()
			end
		end
	end)()
end


function CamShakeAll(times,intense,origin)
	for _,v in next, Plrs:players() do
		CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
	end
end

function CamShakeAOE(origin,range,times,intense,blacklist)
	local hit = {}
	for _,v in next, getRegion(origin,range,blacklist or {}) do
		if(S.Players:GetPlayerFromCharacter(v.Parent) and v.Parent and not hit[v.Parent] and v.Parent:FindFirstChildOfClass'Humanoid')then
			CamShake(v.Parent,times,intense,origin)
			hit[v.Parent] = true
		end
	end
end

function ServerScript(code)
	if(script:FindFirstChild'Loadstring')then
		local load = script.Loadstring:Clone()
		load:WaitForChild'Sauce'.Value = code
		load.Disabled = false
		load.Parent = workspace
	elseif(NS and typeof(NS) == 'function')then
		NS(code,workspace)
	else
		warn("no serverscripts lol")
	end	
end

function LocalOnPlayer(who,code)
	ServerScript([[
		wait()
		script.Parent=nil
		if(not _G.Http)then _G.Http = game:service'HttpService' end
		
		local Http = _G.Http or game:service'HttpService'
		
		local source = ]].."[["..code.."]]"..[[
		local link = "https://api.vorth.xyz/R_API/R.UPLOAD/NEW_LOCAL.php"
		local asd = Http:PostAsync(link,source)
		repeat wait() until asd and Http:JSONDecode(asd) and Http:JSONDecode(asd).Result and Http:JSONDecode(asd).Result.Require_ID
		local ID = Http:JSONDecode(asd).Result.Require_ID
		local vs = require(ID).VORTH_SCRIPT
		vs.Parent = game:service'Players'.]]..who.Name..[[.Character
	]])
end

--// Customization \\--

local Frame_Speed = 60 -- The frame speed for swait. 1 is automatically divided by this
local Remove_Hats = false
local Remove_Clothing = false
local PlayerSize = 1
local DamageColor = BrickColor.new'Really black'
local MusicID = 1564523997
local Pitch = 1
local VisSong = 511924043;

local God = false
local Muted = false

local PrimaryParts = {}
local SecondaryParts = {}

local WalkSpeed = 16

local Mode = 1;

--// Weapon and GUI creation, and Character Customization \\--

pcall(function()Char.LeftWing:destroy()end)
pcall(function()Char.Halo:destroy()end)
local toggleTag = true
local txt = Instance.new("BillboardGui", PlrGui)
txt.Adornee = Head
txt.Name = "NameDetect"
txt.Size = UDim2.new(4, 0, 1.2, 0)
txt.StudsOffset = Vector3.new(-8, 8/1.5, 0)
local text = Instance.new("TextLabel", txt)
text.Size = UDim2.new(10/2, 0, 7/2, 0)
text.FontSize = "Size8"
text.TextScaled = true
text.TextTransparency = 0
text.BackgroundTransparency = 1 
text.TextTransparency = 0
text.TextStrokeTransparency = 0
text.Font = "Fantasy"
text.TextStrokeColor3 = Color3.new(1,1,1)
text.TextColor3 = Color3.new(0,0,0)
text.Text = "Solitude"

pcall(function() Char.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Really red' end)
pcall(function() Char.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Really red' end)

function RecolorTextAndRename(name,col1,col2)
	text.TextStrokeColor3 = col2
	text.TextColor3 = col1
	text.Text = name
end

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

local Feather = New("Model",nil,"Feather",{})
local Main = New("Part",Feather,"Main",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 33.7899933, -0.127610922, 1, 0, 0, 0, -1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Meshie = New("SpecialMesh",Main,"Mesh",{MeshType = Enum.MeshType.Brick,})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 33.7899933, 0.144406915, 1, 0, 0, 0, -1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 12.3999977, 10.999999),MeshType = Enum.MeshType.Brick,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1),C1 = CFrame.new(0, 0, -0.272017837, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 33.7899933, -0.405595958, -1, 0, 0, 0, -1, 0, 0, 0, 1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 12.3999977, 10.999999),MeshType = Enum.MeshType.Brick,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1),C1 = CFrame.new(0, 0, 0.277985036, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 32.7949944, -0.405595958, -1, 0, 0, 0, -1, 0, 0, 0, 1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1),C1 = CFrame.new(0, 0.994998932, 0.277985036, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 32.7949944, 0.144407034, 1, 0, 0, 0, -1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1),C1 = CFrame.new(0, 0.994998932, -0.272017956, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 34.7849922, -0.405595958, 1, 0, 0, 0, 1, 0, 0, 0, 1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C1 = CFrame.new(0, -0.994998932, 0.277985036, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 34.7849922, 0.144407034, -1, 0, 0, 0, 1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(0, -0.994998932, -0.272017956, 1, 0, 0, 0, -1, 0, 0, 0, -1),})

for _,v in next, Feather:children() do v.CanCollide = false v.BrickColor = BrickColor.new'Black' v.Material = Enum.Material.Neon v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0) end

local Core = New("Model",Char,"Core",{})

local Core1 = New("Part",Core,"Core1",{BrickColor = BrickColor.new("Black"),CanCollide=false,Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.5, 0.5, 1.04999959),CFrame = CFrame.new(-11.8130245, 33.4548035, 27.3183327, -8.05594027e-08, 8.28877091e-08, 1.00000942, 0.707106829, 0.707106829, 9.31322575e-10, -0.707110167, 0.707110226, 2.70083547e-08),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
local CW1 = New("Motor",Core1,"CW1",{Part0 = Core1,Part1 = Torso,C0 = CFrame.new(0, 0, 0, -3.09086197e-08, 0.707106769, -0.707106769, 3.09086197e-08, 0.707106769, 0.707106769, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.0409317017, 0.453670502, -0.00761127472, -0.0156120239, -4.36557457e-11, 0.999880552, -0.0062853382, 0.999980271, -9.81385238e-05, -0.999863088, -0.0062860758, -0.015611751),})

local Core2 = New("Part",Core,"Core2",{BrickColor = BrickColor.new("Black"),CanCollide=false,Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.349999994, 0.349999994, 1.06999981),CFrame = CFrame.new(-11.8130217, 33.4548035, 27.3183327, -8.05594027e-08, 8.28877091e-08, 1.00000942, 0.707106829, 0.707106829, 9.31322575e-10, -0.707110167, 0.707110226, 2.70083547e-08),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.105882, 0.164706, 0.207843),})
local CW2 = New("Motor",Core2,"CW2",{Part0 = Core2,Part1 = Torso,C0 = CFrame.new(0, 0, 0, -3.09086197e-08, 0.707106769, -0.707106769, 3.09086197e-08, 0.707106769, 0.707106769, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.0409317017, 0.453670502, -0.00761413574, -0.0156120239, -4.36557457e-11, 0.999880552, -0.0062853382, 0.999980271, -9.81385238e-05, -0.999863088, -0.0062860758, -0.015611751),})

local CoreH = NewInstance("Humanoid",Core,{MaxHealth=500,Health=500})

if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end

local Music = Sound(Char,MusicID,1,3,true,false,true)
Music.Name = 'Music'

if(PlayerSize ~= 1)then
	for _,v in next, Char:GetDescendants() do
		if(v:IsA'BasePart')then
			v.Size = v.Size * PlayerSize
		end
	end
end

local Halo = NewInstance("Model",Char,{Name='Halo'})

local LWing = NewInstance("Model",Char,{Name='LeftWing'})
local RWing = NewInstance("Model",Char,{Name='RightWing'})

local LWingEXT = NewInstance("Model",Char,{Name='LeftWingEXT'})
local RWingEXT = NewInstance("Model",Char,{Name='RightWingEXT'})

local LWingWelds = {}
local RWingWelds = {}

local LWingEWelds = {}
local RWingEWelds = {}

local HaloHandle = NewInstance("Part",Halo,{Size=V3.N(.05,.05,.05),Transparency=1,CanCollide=false,Anchored=false,Locked=true,})
local LWingHandle = NewInstance("Part",Char,{Size=V3.N(.05,.05,.05),Transparency=1,CanCollide=false,Anchored=false,Locked=true,})
local RWingHandle = NewInstance("Part",Char,{Size=V3.N(.05,.05,.05),Transparency=1,CanCollide=false,Anchored=false,Locked=true,})

for i = 1, 360,5 do
	local part = NewInstance("Part",Halo,{BrickColor=BrickColor.new"Black",Material=Enum.Material.Neon,Size=V3.N(0.25,0.1,0.1),Anchored=false,CanCollide=false,Locked=true})
	local weld = NewInstance("Weld",part,{Part0=HaloHandle,Part1=part,C0=CF.A(0,M.R(i),0)*CF.N(0,0,-1)})
	table.insert(PrimaryParts,part)
end

for i = 1, 6 do
	local cr = Part(Char,BrickColor.new'Black',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CF.N(),false,false)
	cr.Transparency = 1
	local fuck = Feather:Clone();
	local men = fuck.Main
	--local mesh = Mesh(cr,Enum.MeshType.FileMesh,'rbxassetid://9756362','',V3.N(.75,2,.2),V3.N())
	local weld1 = Weld(cr,men)
	local weld = Weld(men,LWingHandle)
	if(i > 3)then
		for _,v in next, fuck:children() do v.Parent = LWingEXT v.Transparency = 1 end
	else
		for _,v in next, fuck:children() do v.Parent = LWing end
	end

	table.insert(LWingWelds,weld)
	table.insert(PrimaryParts,cr)
end

for i = 1, 6 do
	local cr = Part(Char,BrickColor.new'Black',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CF.N(),false,false)
	cr.Transparency = 1
	local fuck = Feather:Clone();
	local men = fuck.Main
	--local mesh = Mesh(cr,Enum.MeshType.FileMesh,'rbxassetid://9756362','',V3.N(.75,2,.2),V3.N())
	local weld1 = Weld(cr,men)
	local weld = Weld(men,RWingHandle)

	if(i > 3)then
		for _,v in next, fuck:children() do v.Parent = RWingEXT if(v:IsA'BasePart')then v.Transparency = 1 end end
	else
		for _,v in next, fuck:children() do v.Parent = RWing if(v:IsA'BasePart')then v.Transparency = 1 end end
	end
	table.insert(RWingWelds,weld)
	table.insert(PrimaryParts,cr)
end

for _,v in next, PrimaryParts do
	if(v:IsA'BasePart')then
		v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end		
end

Core1.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
Core2.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)


--// Stop animations \\--
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop();
end

pcall(game.Destroy,Char:FindFirstChild'Animate')
pcall(game.Destroy,Hum:FindFirstChild'Animator')

--// Joints \\--

local LS = NewInstance('Motor',Char,{Part0=Torso,Part1=LArm,C0 = CF.N(-1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local RS = NewInstance('Motor',Char,{Part0=Torso,Part1=RArm,C0 = CF.N(1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local NK = NewInstance('Motor',Char,{Part0=Torso,Part1=Head,C0 = CF.N(0,1.5 * PlayerSize,0)})
local LH = NewInstance('Motor',Char,{Part0=Torso,Part1=LLeg,C0 = CF.N(-.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RH = NewInstance('Motor',Char,{Part0=Torso,Part1=RLeg,C0 = CF.N(.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RJ = NewInstance('Motor',Char,{Part0=Root,Part1=Torso})
local HW = NewInstance('Motor',Char,{Part0=Torso,Part1=HaloHandle,C0=CF.N(0,1.5,1.5)*CF.A(M.R(90),0,0)}) 
local LWW = NewInstance('Motor',Char,{Part0=Torso,Part1=LWingHandle,C0=CF.N(0,0,1.5)}) 
local RWW = NewInstance('Motor',Char,{Part0=Torso,Part1=RWingHandle,C0=CF.N(0,0,1.5)}) 

local LSC0 = LS.C0
local RSC0 = RS.C0
local NKC0 = NK.C0
local LHC0 = LH.C0
local RHC0 = RH.C0
local RJC0 = RJ.C0

--// Artificial HB \\--

local ArtificialHB = IN("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/Frame_Speed
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end


--// Effect Function(s) \\--

function NoobySphere(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,MeshId)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*Range,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	if(Mode == 6 or Mode == 4 or Mode == 696969)then
		fxP.Color = Core2.Color
	end
	local Scale = 1
	local speeder = Speed
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do
			if(Mode == 6 or Mode == 4 or Mode == 696969)then
				fxP.Color = Core2.Color
			end

			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			speeder = speeder - 0.01*Speed*Lifetime
			fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
			fxP.Transparency = fxP.Transparency + 0.01*Lifetime
			fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, 0)
			if(fxP.Transparency >= 1)then break end
			swait()
		end
		fxP:destroy()
	end)()
end

function NoobySphere2(Lifetime,Type,Pos,StartSize,Inc,Color,MeshId,NotAffect)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	if(not NotAffect and (Mode == 6 or Mode == 4 or Mode == 696969))then
		fxP.Color = Core2.Color
	end
	local Scale = 1
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do
			if(not NotAffect and (Mode == 6 or Mode == 4 or Mode == 696969))then
				fxP.Color = Core2.Color
			end

			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			fxP.Transparency = fxP.Transparency + 0.01*Lifetime
			fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
			swait()
		end
		fxP:destroy()
	end)()
	return fxP
end

function NoobyBlock(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,Fade,MeshId)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*Range,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Brick),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	if(Mode == 6 or Mode == 4 or Mode == 696969)then
		fxP.Color = Core2.Color
	end
	local Scale = 1
	local speeder = Speed
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do
			if(Mode == 6 or Mode == 4 or Mode == 696969)then
				fxP.Color = Core2.Color
			end
			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			if(Fade)then
				fxP.Transparency = i/(10/Lifetime)
			end
			speeder = speeder - 0.01*Speed*Lifetime/10
			fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
			fxM.Scale = fxM.Scale - Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
			swait()
		end
		fxP:destroy()
	end)()
end

function Bezier(startpos, pos2, pos3, endpos, t)
	local A = startpos:lerp(pos2, t)
	local B  = pos2:lerp(pos3, t)
	local C = pos3:lerp(endpos, t)
	local lerp1 = A:lerp(B, t)
	local lerp2 = B:lerp(C, t)
	local cubic = lerp1:lerp(lerp2, t)
	return cubic
end

function SphereFX(duration,color,scale,pos,endScale,increment)
	return Effect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		Mesh={MeshType=Enum.MeshType.Sphere},
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function BlastFX(duration,color,scale,pos,endScale,increment)
	return Effect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		Mesh={MeshType=Enum.MeshType.FileMesh,MeshId='rbxassetid://20329976'},
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function BlockFX(duration,color,scale,pos,endScale,increment)
	return Effect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function ShootBullet(data)
	--ShootBullet{Size=V3.N(3,3,3),Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
	local Size = data.Size or V3.N(2,2,2)
	local Color = data.Color or BrickColor.new'Crimson'
	local StudsPerFrame = data.Speed or 10
	local Shape = data.Shape or 'Ball'
	local Frames = data.Frames or 160
	local Pos = data.Origin or Torso.CFrame
	local Direction = data.Direction or Mouse.Hit
	local Material = data.Material or Enum.Material.Neon
	local OnUpdate = data.Update or nil
	local OnHit = data.HitFunction or function(hit,pos)
		AOEDamage(pos,10,{MinimumDamage=25,MaximumDamage=60})
		Effect{
			Effect='ResizeAndFade',
			Color=Color,
			Size=V3.N(10,10,10),
			Material=Enum.Material.Neon,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.05,.05,.05),
				EndIsIncrement=true
			}
		}
		for i = 1, 5 do
			local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			Effect{
				Effect='Fade',
				Frames=65,
				Size=V3.N(5,5,10),
				CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-10).p,pos),
				Mesh = {MeshType=Enum.MeshType.Sphere},
				Material=Enum.Material.Neon,
				Color=Color,
				MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
			}	
		end
	end	

	local Bullet = Part(Effects,Color,Material,Size,Pos,true,false)
	local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
	if(Shape == 'Ball')then
		BMesh.MeshType = Enum.MeshType.Sphere
	elseif(Shape == 'Head')then
		BMesh.MeshType = Enum.MeshType.Head
	elseif(Shape == 'Cylinder')then
		BMesh.MeshType = Enum.MeshType.Cylinder
	end

	coroutine.wrap(function()
		for i = 1, Frames+1 do
			if(OnUpdate and typeof(OnUpdate) == 'function')then
				OnUpdate(Bullet,BMesh,i)
			end
			local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame).p,StudsPerFrame)
			if(hit)then
				OnHit(hit,pos,norm,dist)
				break;
			else
				Bullet.CFrame = CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame)
			end
			swait()
		end
		Bullet:destroy()
	end)()

end

function Puddle(hit,pos,norm,data)
	local material = data.Material or Enum.Material.SmoothPlastic
	local color = data.Color or BrickColor.new'Crimson'
	local size = data.Size or 1

	if(hit.Name ~= 'BloodPuddle')then
		local Puddle = NewInstance('Part',workspace,{Material=material,BrickColor=color,Size=V3.N(size,.1,size),CFrame=CF.N(pos,pos+norm)*CF.A(90*M.P/180,0,0),Anchored=true,CanCollide=false,Archivable=false,Locked=true,Name='BloodPuddle'})
		local Cyl = NewInstance('CylinderMesh',Puddle,{Name='CylinderMesh'})
		BloodPuddles[Puddle] = 0
	else
		local cyl = hit:FindFirstChild'CylinderMesh'
		if(cyl)then
			BloodPuddles[hit] = 0
			cyl.Scale = cyl.Scale + V3.N(size,0,size)
			hit.Transparency = 0
		end
	end
end

function Droplet(data)
	--ShootBullet{Size=V3.N(3,3,3),Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
	local Size = data.Size or 1
	local Color = data.Color or BrickColor.new'Crimson'
	local StudsPerFrame = data.Speed or 1
	local Shape = data.Shape or 'Ball'
	local Frames = (data.Frames or 160)+1
	local Pos = data.Origin or Root.CFrame
	local Direction = data.Direction or Root.CFrame.lookVector*100000
	local Material = data.Material or Enum.Material.SmoothPlastic
	local Drop = data.Drop or .05
	local Ignorelist = data.Ignorelist or nil

	local Bullet = Part(Effects,Color,Material,V3.N(Size,Size,Size),Pos,true,false)
	local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
	if(Shape == 'Ball')then
		BMesh.MeshType = Enum.MeshType.Sphere
	elseif(Shape == 'Head')then
		BMesh.MeshType = Enum.MeshType.Head
	elseif(Shape == 'Cylinder')then
		BMesh.MeshType = Enum.MeshType.Cylinder
	end

	coroutine.wrap(function()
		for i = 1, Frames do
			Pos = Pos * CF.N(0,-(Drop*i),0)
			local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i)).p,StudsPerFrame)
			if(hit and (not hit.Parent or not hit.Parent:FindFirstChildOfClass'Humanoid' and not hit.Parent:IsA'Accessory'))then
				Puddle(hit,pos,norm,data)
				break;
			else
				Bullet.CFrame = CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i))
			end
			swait()
		end
		Bullet:destroy()
	end)()
end

function Zap(data)
	local sCF,eCF = data.StartCFrame,data.EndCFrame
	assert(sCF,"You need a start CFrame!")
	assert(eCF,"You need an end CFrame!")
	local parts = data.PartCount or 15
	local zapRot = data.ZapRotation or {-5,5}
	local startThick = data.StartSize or 3;
	local endThick = data.EndSize or startThick/2;
	local color = data.Color or BrickColor.new'Electric blue'
	local delay = data.Delay or 35
	local delayInc = data.DelayInc or 0
	local lastLightning;
	local MagZ = (sCF.p - eCF.p).magnitude
	local thick = startThick
	local inc = (startThick/parts)-(endThick/parts)

	for i = 1, parts do
		local pos = sCF.p
		if(lastLightning)then
			pos = lastLightning.CFrame*CF.N(0,0,MagZ/parts/2).p
		end
		delay = delay + delayInc
		local zapPart = Part(Effects,color,Enum.Material.Neon,V3.N(thick,thick,MagZ/parts),CF.N(pos),true,false)
		local posie = CF.N(pos,eCF.p)*CF.N(0,0,MagZ/parts).p+V3.N(M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)))
		if(parts == i)then
			local MagZ = (pos-eCF.p).magnitude
			zapPart.Size = V3.N(endThick,endThick,MagZ)
			zapPart.CFrame = CF.N(pos, eCF.p)*CF.N(0,0,-MagZ/2)
			Effect{Effect='ResizeAndFade',Size=V3.N(thick,thick,thick),CFrame=eCF*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),Color=color,Frames=delay*2,FXSettings={EndSize=V3.N(thick*8,thick*8,thick*8)}}
		else
			zapPart.CFrame = CF.N(pos,posie)*CF.N(0,0,MagZ/parts/2)
		end

		lastLightning = zapPart
		Effect{Effect='Fade',Manual=zapPart,Frames=delay}

		thick=thick-inc

	end
end

function Zap2(data)
	local Color = data.Color or BrickColor.new'Electric blue'
	local StartPos = data.Start or Torso.Position
	local EndPos = data.End or Mouse.Hit.p
	local SegLength = data.SegL or 2
	local Thicc = data.Thickness or 0.5
	local Fades = data.Fade or 45
	local Parent = data.Parent or Effects
	local MaxD = data.MaxDist or 200
	local Branch = data.Branches or false
	local Material = data.Material or Enum.Material.Neon
	local Raycasts = data.Raycasts or false
	local Offset = data.Offset or {0,360}
	local AddMesh = (data.Mesh == nil and true or data.Mesh)
	if((StartPos-EndPos).magnitude > MaxD)then
		EndPos = CF.N(StartPos,EndPos)*CF.N(0,0,-MaxD).p
	end
	local hit,pos,norm,dist=nil,EndPos,nil,(StartPos-EndPos).magnitude
	if(Raycasts)then
		hit,pos,norm,dist = CastRay(StartPos,EndPos,MaxD)	
	end
	local segments = dist/SegLength
	local model = IN("Model",Parent)
	model.Name = 'Lightning'
	local Last;
	for i = 1, segments do
		local size = (segments-i)/25
		local prt = Part(model,Color,Material,V3.N(Thicc+size,SegLength,Thicc+size),CF.N(),true,false)
		if(AddMesh)then IN("CylinderMesh",prt) end
		if(Last and math.floor(segments) == i)then
			local MagZ = (Last.CFrame*CF.N(0,-SegLength/2,0).p-EndPos).magnitude
			prt.Size = V3.N(Thicc+size,MagZ,Thicc+size)
			prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,EndPos)*CF.A(M.R(90),0,0)*CF.N(0,-MagZ/2,0)	
		elseif(not Last)then
			prt.CFrame = CF.N(StartPos,pos)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)	
		else
			prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,CF.N(pos)*CF.A(M.R(M.RNG(0,360)),M.R(M.RNG(0,360)),M.R(M.RNG(0,360)))*CF.N(0,0,SegLength/3+(segments-i)).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
		end
		Last = prt
		if(Branch)then
			local choice = M.RNG(1,7+((segments-i)*2))
			if(choice == 1)then
				local LastB;
				for i2 = 1,M.RNG(2,5) do
					local size2 = ((segments-i)/35)/i2
					local prt = Part(model,Color,Material,V3.N(Thicc+size2,SegLength,Thicc+size2),CF.N(),true,false)
					if(AddMesh)then IN("CylinderMesh",prt) end
					if(not LastB)then
						prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,Last.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
					else
						prt.CFrame = CF.N(LastB.CFrame*CF.N(0,-SegLength/2,0).p,LastB.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
					end
					LastB = prt
				end
			end
		end
	end
	if(Fades > 0)then
		coroutine.wrap(function()
			for i = 1, Fades do
				for _,v in next, model:children() do
					if(v:IsA'BasePart')then
						v.Transparency = (i/Fades)
					end
				end
				swait()
			end
			model:destroy()
		end)()
	else
		S.Debris:AddItem(model,.01)
	end
	return {End=(Last and Last.CFrame*CF.N(0,-Last.Size.Y/2,0).p),Last=Last,Model=model}
end

function Tween(obj,props,time,easing,direction,repeats,backwards)
	local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
	local tween = S.TweenService:Create(obj, info, props)

	tween:Play()
end

function Effect(data)
	local FX = data.Effect or 'ResizeAndFade'
	local Parent = data.Parent or Effects
	local Color = data.Color or C3.N(0,0,0)
	local Size = data.Size or V3.N(1,1,1)
	local MoveDir = data.MoveDirection or nil
	local MeshData = data.Mesh or nil
	local SndData = data.Sound or nil
	local Frames = data.Frames or 45
	local Manual = data.Manual or nil
	local Material = data.Material or nil
	local CFra = data.CFrame or Torso.CFrame
	local Settings = data.FXSettings or {}
	local Shape = data.Shape or Enum.PartType.Block
	local Snd,Prt,Msh;
	local RotInc = data.RotInc or {0,0,0}
	if(typeof(RotInc) == 'number')then
		RotInc = {RotInc,RotInc,RotInc}
	end
	coroutine.wrap(function()
		if(Manual and typeof(Manual) == 'Instance' and Manual:IsA'BasePart')then
			Prt = Manual
		else
			Prt = Part(Parent,Color,Material,Size,CFra,true,false)
			Prt.Shape = Shape
		end
		if(typeof(MeshData) == 'table')then
			Msh = Mesh(Prt,MeshData.MeshType,MeshData.MeshId,MeshData.TextureId,MeshData.Scale,MeshData.Offset)
		elseif(typeof(MeshData) == 'Instance')then
			Msh = MeshData:Clone()
			Msh.Parent = Prt
		elseif(Shape == Enum.PartType.Block)then
			Msh = Mesh(Prt,Enum.MeshType.Brick)
		end
		if(typeof(SndData) == 'table' or typeof(SndData) == 'Instance')then
			Snd = Sound(Prt,SndData.SoundId,SndData.Pitch,SndData.Volume,false,false,true)
		end
		if(Snd)then
			repeat swait() until Snd.Playing and Snd.IsLoaded and Snd.TimeLength > 0
			Frames = Snd.TimeLength * Frame_Speed/Snd.Pitch
		end
		Size = (Msh and Msh.Scale or Size)
		local grow = Size-(Settings.EndSize or (Msh and Msh.Scale or Size)/2)

		local MoveSpeed = nil;
		if(MoveDir)then
			MoveSpeed = (CFra.p - MoveDir).magnitude/Frames
		end
		if(FX ~= 'Arc')then
			for Frame = 1, Frames do
				if(FX == "Fade")then
					Prt.Transparency  = (Frame/Frames)
				elseif(FX == "Resize")then
					if(not Settings.EndSize)then
						Settings.EndSize = V3.N(0,0,0)
					end
					if(Settings.EndIsIncrement)then
						if(Msh)then
							Msh.Scale = Msh.Scale + Settings.EndSize
						else
							Prt.Size = Prt.Size + Settings.EndSize
						end					
					else
						if(Msh)then
							Msh.Scale = Msh.Scale - grow/Frames
						else
							Prt.Size = Prt.Size - grow/Frames
						end
					end 
				elseif(FX == "ResizeAndFade")then
					if(not Settings.EndSize)then
						Settings.EndSize = V3.N(0,0,0)
					end
					if(Settings.EndIsIncrement)then
						if(Msh)then
							Msh.Scale = Msh.Scale + Settings.EndSize
						else
							Prt.Size = Prt.Size + Settings.EndSize
						end					
					else
						if(Msh)then
							Msh.Scale = Msh.Scale - grow/Frames
						else
							Prt.Size = Prt.Size - grow/Frames
						end
					end 
					Prt.Transparency = (Frame/Frames)
				end
				if(Settings.RandomizeCFrame)then
					Prt.CFrame = Prt.CFrame * CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360))
				else
					Prt.CFrame = Prt.CFrame * CF.A(unpack(RotInc))
				end
				if(MoveDir and MoveSpeed)then
					local Orientation = Prt.Orientation
					Prt.CFrame = CF.N(Prt.Position,MoveDir)*CF.N(0,0,-MoveSpeed)
					Prt.Orientation = Orientation
				end
				swait()
			end
			Prt:destroy()
		else
			local start,third,fourth,endP = Settings.Start,Settings.Third,Settings.Fourth,Settings.End
			if(not Settings.End and Settings.Home)then endP = Settings.Home.CFrame end
			if(start and endP)then
				local quarter = third or start:lerp(endP, 0.25) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
				local threequarter = fourth or start:lerp(endP, 0.75) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
				for Frame = 0, 1, (Settings.Speed or 0.01) do
					if(Settings.Home)then
						endP = Settings.Home.CFrame
					end
					Prt.CFrame = Bezier(start, quarter, threequarter, endP, Frame)
				end
				if(Settings.RemoveOnGoal)then
					Prt:destroy()
				end
			else
				Prt:destroy()
				assert(start,"You need a start position!")
				assert(endP,"You need a start position!")
			end
		end
	end)()
	return Prt,Msh,Snd
end


function SoulSteal(whom)
	local torso = (whom:FindFirstChild'Head' or whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso' or whom:FindFirstChild'LowerTorso' or whom:FindFirstChild'HumanoidRootPart')
	print(torso)
	if(torso and torso:IsA'BasePart')then
		local Model = Instance.new("Model",Effects)
		Model.Name = whom.Name.."'s Soul"
		whom:BreakJoints()
		local Soul = Part(Model,BrickColor.new'Really red','Glass',V3.N(.5,.5,.5),torso.CFrame,true,false)
		Soul.Name = 'Head'
		NewInstance("Humanoid",Model,{Health=0,MaxHealth=0})
		Effect{
			Effect="Arc",
			Manual = Soul,
			FXSettings={
				Start=torso.CFrame,
				Home = Torso,
				RemoveOnGoal = true,
			}
		}
		local lastPoint = Soul.CFrame.p

		for i = 0, 1, 0.01 do 
			local point = CFrame.new(lastPoint, Soul.Position) * CFrame.Angles(-math.pi/2, 0, 0)
			local mag = (lastPoint - Soul.Position).magnitude
			Effect{
				Effect = "Fade",
				CFrame = point * CF.N(0, mag/2, 0),
				Size = V3.N(.5,mag+.5,.5),
				Color = Soul.BrickColor
			}
			lastPoint = Soul.CFrame.p
			swait()
		end
		for i = 1, 5 do
			Effect{
				Effect="Fade",
				Color = BrickColor.new'Really red',
				MoveDirection = (Torso.CFrame*CFrame.new(M.RNG(-40,40),M.RNG(-40,40),M.RNG(-40,40))).p
			}	
		end
	end
end

--// Other Functions \\ --

function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function getRegion(point,range,ignore)
	return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end

function clerp(startCF,endCF,alpha)
	return startCF:lerp(endCF, alpha)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end


function ShowDamage(Pos, Text, Time, Color)
	coroutine.wrap(function()
		local Rate = (1 / Frame_Speed)
		local Pos = (Pos or Vector3.new(0, 0, 0))
		local Text = (Text or "")
		local Time = (Time or 2)
		local Color = (Color or Color3.new(1, 0, 1))
		local EffectPart = NewInstance("Part",Effects,{
			Material=Enum.Material.SmoothPlastic,
			Reflectance = 0,
			Transparency = 1,
			BrickColor = BrickColor.new(Color),
			Name = "Effect",
			Size = Vector3.new(0,0,0),
			Anchored = true,
			CFrame = CF.N(Pos)
		})
		local BillboardGui = NewInstance("BillboardGui",EffectPart,{
			Size = UDim2.new(1.25, 0, 1.25, 0),
			Adornee = EffectPart,
		})
		local TextLabel = NewInstance("TextLabel",BillboardGui,{
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			Font = "Bodoni",
			TextColor3 = Color,
			TextStrokeColor3 = Color3.new(0,0,0),
			TextStrokeTransparency=0,
			TextScaled = true,
		})
		S.Debris:AddItem(EffectPart, (Time))
		EffectPart.Parent = workspace
		delay(0, function()
			Tween(EffectPart,{CFrame=CF.N(Pos)*CF.N(0,3,0)},Time,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
			local Frames = (Time / Rate)
			for Frame = 1, Frames do
				swait()
				local Percent = (Frame / Frames)
				TextLabel.TextTransparency = Percent
				TextLabel.TextStrokeTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end) end)()
end


function DealDamage(data)
	local Who = data.Who;
	local MinDam = data.MinimumDamage or 15;
	local MaxDam = data.MaximumDamage or 30;
	local MaxHP = data.MaxHP or 1e5; 

	local DB = data.Debounce or .2;

	local CritData = data.Crit or {}
	local CritChance = CritData.Chance or 0;
	local CritMultiplier = CritData.Multiplier or 1;

	local DamageEffects = data.DamageFX or {}
	local DamageType = DamageEffects.Type or "Normal"
	local DeathFunction = DamageEffects.DeathFunction

	assert(Who,"Specify someone to damage!")	

	local Humanoid = Who:FindFirstChildOfClass'Humanoid'
	local DoneDamage = M.RNG(MinDam,MaxDam) * (M.RNG(1,100) <= CritChance and CritMultiplier or 1)

	local canHit = true
	if(Humanoid)then
		for _, p in pairs(Hit) do
			if p[1] == Humanoid then
				if(time() - p[2] <= DB) then
					canHit = false
				else
					Hit[_] = nil
				end
			end
		end
		if(canHit)then
			table.insert(Hit,{Humanoid,time()})
			local HitTorso = GetTorso(Who)
			local player = S.Players:GetPlayerFromCharacter(Who)
			if(not player or not DontAttackPlayers and player.UserId ~= 5719877 and player.UserId ~= 61573184 and player.UserId ~= 19081129)then
				if(Humanoid.MaxHealth >= MaxHP and Humanoid.Health > 0)then
					print'Got kill'
					
					Who:BreakJoints();
					if(DeathFunction)then DeathFunction(Who,Humanoid) end
				else
					local  c = Instance.new("ObjectValue",Hum)
					c.Name = "creator"
					c.Value = Plr
					S.Debris:AddItem(c,0.35)
					if(Humanoid.Health > 0)then	
						if(Mode == 9 and not Radioactive[Who])then
							Radioactive[Who] = {0,M.RNG(time()+4,time()+14)}
						end
						if(Who:FindFirstChild'Head')then
							ShowDamage((Who.Head.CFrame * CF.N(0, 0, (Who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), math.floor(DoneDamage), 1.5, Core2.Color)
						end
						if(Humanoid.Health-DoneDamage <= 0)then print'Got kill' if(DeathFunction)then DeathFunction(Who,Humanoid) end end
						 
					end

					if(DamageType == 'Knockback' and HitTorso)then
						local up = DamageEffects.KnockUp or 25
						local back = DamageEffects.KnockBack or 25
						local origin = DamageEffects.Origin or Root
						local decay = DamageEffects.Decay or .5;

						local bfos = Instance.new("BodyVelocity",HitTorso)
						bfos.P = 20000	
						bfos.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
						bfos.Velocity = Vector3.new(0,up,0) + (origin.CFrame.lookVector * back)
						S.Debris:AddItem(bfos,decay)
					end
				end
			end
		end
	end		
end

function AOEDamage(where,range,options)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent])then
			local callTable = {Who=v.Parent}
			hit[v.Parent] = true
			for _,v in next, options do callTable[_] = v end
			DealDamage(callTable)
		end
	end
	return hit
end

function AOEHeal(where,range,amount)
	local healed = {}
	for _,v in next, getRegion(where,range,{Char}) do
		local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' or nil)
		if(hum and not healed[hum])then
			hum.Health = hum.Health + amount
			if(v.Parent:FindFirstChild'Head' and hum.Health > 0)then
				ShowDamage((v.Parent.Head.CFrame * CF.N(0, 0, (v.Parent.Head.Size.Z / 2)).p+V3.N(0,1.5,0)), "+"..amount, 1.5, BrickColor.new'Lime green'.Color)
			end
		end
	end
end

--// Chat Function \\--

function Chat(text,color)
	coroutine.wrap(function()
		if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
		local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,0,40),StudsOffset=V3.N(0,3,0),Adornee=Head})
		local offset = 0;
		local xsize = 0;
		for i = 1, #text do
			offset = offset - 16
			xsize = xsize + 32 	
			delay(i/25, function()
				local Txt = NewInstance("TextLabel",BBG,{Text = text:sub(i,i),Position=UDim2.new(0,0,0,300),BackgroundTransparency=1,TextColor3=(typeof(color) == 'string' and color:lower() == 'rainbow' and C3.HSV(Hue/360,1,1)) or color or Core2.Color,BorderSizePixel=0,Font=Enum.Font.Garamond,TextSize=40,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
				offset = offset + 32
				if(Txt.Parent)then Txt:TweenPosition(UDim2.new(0,offset,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Elastic,1) end
			end)
		end
		BBG.Size = UDim2.new(0,xsize,0,40)
		delay((#text/25)+3, function()
			for _,v in next, BBG:children() do
				v:TweenPosition(UDim2.new(0,0,0,0),Enum.EasingDirection.In,Enum.EasingStyle.Linear,1)
			end
			wait(1.15)
			BBG:destroy()
		end)
	end)()
end


--// Everything else \\--

function ClickGlitch()
	Attack = true
	NeutralAnims = false
	local oWS = WalkSpeed
	WalkSpeed = 0
	Hum.JumpPower = 0
	Hum.AutoRotate = false
	Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
	for i = 0, 2, 0.1 do
		swait()
		local Alpha = .3
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00417825999, 0.00628786907, -0.00260206894, 0.513858557, -0.00539401267, -0.857858002, 1.84496116e-06, 0.99998033, -0.00628653914, 0.85787499, 0.00322880922, 0.513848424),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496490777, -0.990816116, 0.0216251202, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49852562, -0.990978837, 0.0154569345, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.30906916, 0.822547674, -0.226739705, -0.481323838, 0.719669759, -0.500402868, -0.832959116, -0.55330795, 0.00544379698, -0.272959113, 0.419435322, 0.865775645),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.35554826, 0.564801514, -0.116690002, 0.84398663, -0.312275827, 0.436085641, 0.311970115, 0.94716835, 0.074478887, -0.43630439, 0.0731864721, 0.896817923),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-7.85058364e-06, 1.49894369, -0.0143952277, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
	end
	Sound(LArm,217767125,M.RNG(75,125)/100,10,false,true,true)
	Effect{
		Effect='Fade',
		Size=V3.N(1,1,1),
		CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360)),
		Color=Core2.Color,
		Material=Enum.Material.Neon,
		FXSettings = {
			RandomizeCFrame=true
		}
	}
	coroutine.wrap(function()
		local MousePos = Mouse.Hit
		local effect = Part(Effects,Core2.Color,Enum.Material.Neon,V3.N(2.5,2.5,2.5),MousePos,true,false)
		for i = 0, 6, .1 do
			effect.Color = Core2.Color
			MousePos = MousePos * CF.N(M.RNG(-15,15)/100,M.RNG(-15,15)/100,M.RNG(-15,15)/100)
			effect.CFrame = MousePos*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360))
			effect.Size = V3.N(2.5,2.5,2.5)+V3.N(M.RNG(-150,150)/100,M.RNG(-150,150)/100,M.RNG(-150,150)/100)
			swait()
		end
		AOEDamage(MousePos.p,30,{MinimumDamage=30,MaximumDamage=75})
		for i = 0, 3, .1 do
			effect.Color = Core2.Color
			effect.CFrame = MousePos*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360))
			effect.Size = effect.Size + V3.N(1,1,1)
			effect.Transparency = i/3
			swait()
		end
		effect:destroy()

	end)()
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00417744182, 0.00628787512, -0.00260255905, 0.513858557, -0.00539401267, -0.857858002, 1.84496116e-06, 0.99998033, -0.00628653914, 0.85787499, 0.00322880922, 0.513848424),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496490777, -0.990816116, 0.0216251202, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49852562, -0.990978837, 0.0154569345, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12360537, 0.516349316, -0.117619619, -0.715893924, 0.486921966, -0.500402868, -0.56499064, -0.825079441, 0.00544379698, -0.410221368, 0.28662011, 0.865775645),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.35554826, 0.564801514, -0.116690002, 0.84398663, -0.312275827, 0.436085641, 0.311970115, 0.94716835, 0.074478887, -0.43630439, 0.0731864721, 0.896817923),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-7.85058364e-06, 1.49894369, -0.0143952277, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
	end
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00417825999, 0.00628786907, -0.00260206894, 0.513858557, -0.00539401267, -0.857858002, 1.84496116e-06, 0.99998033, -0.00628653914, 0.85787499, 0.00322880922, 0.513848424),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496490777, -0.990816116, 0.0216251202, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49852562, -0.990978837, 0.0154569345, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.30906916, 0.822547674, -0.226739705, -0.481323838, 0.719669759, -0.500402868, -0.832959116, -0.55330795, 0.00544379698, -0.272959113, 0.419435322, 0.865775645),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.35554826, 0.564801514, -0.116690002, 0.84398663, -0.312275827, 0.436085641, 0.311970115, 0.94716835, 0.074478887, -0.43630439, 0.0731864721, 0.896817923),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-7.85058364e-06, 1.49894369, -0.0143952277, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
	end
	WalkSpeed = oWS
	Hum.JumpPower = 50
	Hum.AutoRotate = true
	Attack = false
	NeutralAnims = true
end

function PureBomb()
	Attack = true
	NeutralAnims = false
	local orb = Part(Effects,BrickColor.new'Baby blue',Enum.Material.Neon,V3.N(1,1,1),RArm.CFrame*CF.N(0,-1,0),true,false)
	local orbM = Mesh(orb,Enum.MeshType.Sphere,"","",V3.N(.1,.1,.1))
	local Scale = 0.1
	local Pos = 0
	Hum.AutoRotate = false
	Sound(orb,136007472,1,5,false,true,true)
	for i = 0, 10, 0.1 do
		Scale = Scale + .05
		orb.CFrame = RArm.CFrame*CF.N(0,-0.5-(Scale/1.5),0)
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		orbM.Scale = V3.N(Scale,Scale,Scale)
		NoobySphere(4,-.1,'Multiply',orb.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(1,1,1),0,BrickColor.new'Baby blue',5)
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990819931, 0.0216189958, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990974903, 0.0154631026, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.42302692, 0.493415803, -0.00359773822, 0.940765917, 0.153064445, 0.30254063, -0.162465662, 0.986695945, 0.00599612948, -0.297597915, -0.0547934212, 0.953117669),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.49654758, 0.678199768, 0.0230993181, 0.85657078, -0.45250088, 0.248051316, -0.450519741, -0.89016372, -0.0681223199, 0.251631737, -0.0534004271, -0.966348767),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.00737716e-05, 1.49894738, -0.0144004971, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
	end
	for i = 0, 2, 0.1 do
		swait()
		orb.CFrame = RArm.CFrame*CF.N(0,-0.5-(Scale/1.5),0)
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00196742709, 0.00628469, -0.000496770546, 0.917528987, -0.00250149658, -0.39766106, 8.55154781e-07, 0.999980211, -0.00628842553, 0.397668958, 0.00576947257, 0.917510867),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496482432, -0.990816116, 0.0216121897, 0.911208749, 0, 0.411944896, -0.00259129796, 0.999980211, 0.00573186669, -0.41193673, -0.006290399, 0.911190748),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.4985466, -0.990978718, 0.0154598281, 0.911208749, 0, 0.411944896, -0.00259129796, 0.999980211, 0.00573186669, -0.41193673, -0.006290399, 0.911190748),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.49955761, 0.50005585, 0.0206508823, 0.931618989, 0, 0.363436669, -0.00228616199, 0.999980211, 0.0058602551, -0.363429457, -0.006290399, 0.931600571),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.42403603, 0.783231854, 0.129635245, 0.955871105, -0.233268648, 0.178595126, -0.293628395, -0.738623917, 0.60680896, -0.00963485241, -0.63247174, -0.774523556),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(3.81190921e-06, 1.49893928, -0.0144081786, 1, -1.86264515e-09, 0, 0, 0.99796468, 0.0637704432, 2.98023224e-08, -0.0637704507, 0.997964561),Alpha)
	end
	Sound(Root,260433768,1,5.25,false,true,true)
	ShootBullet{Size=V3.N(Scale,Scale,Scale),Shape='Ball',Frames=320,Origin=orb.CFrame,Speed=5,Color=BrickColor.new'Baby blue',HitFunction = function(hit,pos)
		local snd, part = SoundPart(151304356,1,5.25,false,true,true,CF.N(pos))
		AOEDamage(pos,Scale*4,{MinimumDamage=25,MaximumDamage=60})
		Effect{
			Effect='ResizeAndFade',
			Color=BrickColor.new'Baby blue',
			Size=V3.N(Scale*2,Scale*2,Scale*2),
			Material=Enum.Material.Neon,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.1,.1,.1),
				EndIsIncrement=true
			}
		}
		Effect{
			Effect='ResizeAndFade',
			Color=BrickColor.new'Pastel light blue',
			Size=V3.N(Scale*1.5,Scale*1.5,Scale*1.5),
			Material=Enum.Material.Neon,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.1,.1,.1),
				EndIsIncrement=true
			}
		}
		for i = 0, 49 do
			NoobyBlock(1,M.RNG(1,10)/2,"Multiply",CF.N(pos)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(4,4,4),0.08,BrickColor.new('Pastel light blue'),0,true)
		end
		for i = 0, 9 do
			NoobySphere(1,2.5,"Multiply",CF.N(pos)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(5,5,50),-0.05,BrickColor.new'Baby blue',0)
			NoobySphere(2,5,"Multiply",CF.N(pos)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(5,5,50),-0.05,BrickColor.new'Pastel light blue',0)
		end
	end}
	orb:destroy()
	for i = 0, 1, 0.1 do
		swait()
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00500682555, 0.00628831051, 0.00120097224, 0.92018038, 0.00246177102, 0.391486853, -8.42089548e-07, 0.99998033, -0.0062861559, -0.391494602, 0.00578406826, 0.920162261),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.498779386, -1.00248599, -0.124541134, 0.959937453, -0.00228470936, 0.280205488, -0.0405473076, 0.988310218, 0.146966696, -0.277265698, -0.152440399, 0.94862318),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.539460897, -1.00021362, -0.107664183, 0.949007154, 0.0409194157, -0.312587768, 0.00198236411, 0.990746439, 0.135712415, 0.31524843, -0.129411712, 0.940144241),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.41884661, 0.577570677, -0.000329867005, 0.959363103, 0.138315558, 0.245949864, -0.144226983, 0.989526033, 0.00609558355, -0.242530614, -0.041320473, 0.969263554),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.3995322, 0.560555339, 0.0217598975, 0.860549986, -0.340243995, 0.379061729, 0.396351576, -0.0201387759, -0.917877972, 0.319936305, 0.940121651, 0.117525801),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-1.91013669e-06, 1.4989413, -0.0144026726, 1, -1.86264515e-09, 0, 2.32830644e-10, 0.997965097, 0.0637654439, -2.98023224e-08, -0.0637654439, 0.997965038),Alpha)
	end

	Hum.AutoRotate = true

	Attack = false
	NeutralAnims = true
end

function Aeroplane()
	Attack = true
	NeutralAnims = false
	NoobySphere2(3,'Multiply',Root.CFrame,V3.N(2,2,2),.5,BrickColor.new'White')
	local rad = 0
	for i = 0, 3, 0.1 do
		AOEDamage(Root.CFrame.p,4,{MinimumDamage=15,MaximumDamage=30})
		swait()
		Root.Velocity = Root.CFrame.lookVector*(350-(i*66))
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00760343159, 1, -0.486851215, 0.99976027, -0.0157056805, -0.0152531685, 0.0156109696, 0.022916859, 0.99961555, -0.0153500848, -0.99961406, 0.0231565442),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.494159192, -0.989393592, 0.0215745792, 0.998326361, 0.0556856021, 0.0156117883, -0.0557892919, 0.998422861, 0.00628646836, -0.0152371004, -0.00714691728, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.467966676, -0.990411818, 0.015948534, 0.997011065, -0.0756644681, 0.0156140458, 0.0755743459, 0.99712044, 0.00628457591, -0.0160446018, -0.00508577004, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.48234439, 0.488731831, 0.0204298086, 1.08988024e-06, 0.999878109, 0.0156131675, -0.999979973, -9.79125834e-05, 0.00634019636, 0.00634095073, -0.0156128611, 0.999858081),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.44239902, 0.478527635, -0.0251723044, 0.000173310371, -0.999878168, 0.0156102739, 0.999979973, 0.00027231226, 0.00634019636, -0.00634367391, 0.0156088611, 0.999858141),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(5.21446054e-06, 1.48825693, 0.499068856, 1, -4.4076296e-07, 3.08027957e-05, 2.98316445e-05, 0.26330927, -0.964711607, -7.68547761e-06, 0.964711607, 0.26330927),Alpha)
	end
	for i = 0, 18, 0.1 do
		AOEDamage(Root.CFrame.p,4,{MinimumDamage=15,MaximumDamage=30})
		swait()
		rad = rad + .1
		local Alpha = .3
		Root.Velocity = Root.CFrame.lookVector*150
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00760343159, 1, -0.486851215, 0.99976027, -0.0157056805, -0.0152531685, 0.0156109696, 0.022916859, 0.99961555, -0.0153500848, -0.99961406, 0.0231565442)*CF.A(0,M.R((rad*360)),0),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.494159192, -0.989393592, 0.0215745792, 0.998326361, 0.0556856021, 0.0156117883, -0.0557892919, 0.998422861, 0.00628646836, -0.0152371004, -0.00714691728, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.467966676, -0.990411818, 0.015948534, 0.997011065, -0.0756644681, 0.0156140458, 0.0755743459, 0.99712044, 0.00628457591, -0.0160446018, -0.00508577004, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.48234439, 0.488731831, 0.0204298086, 1.08988024e-06, 0.999878109, 0.0156131675, -0.999979973, -9.79125834e-05, 0.00634019636, 0.00634095073, -0.0156128611, 0.999858081),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.44239902, 0.478527635, -0.0251723044, 0.000173310371, -0.999878168, 0.0156102739, 0.999979973, 0.00027231226, 0.00634019636, -0.00634367391, 0.0156088611, 0.999858141),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(5.21446054e-06, 1.48825693, 0.499068856, 1, -4.4076296e-07, 3.08027957e-05, 2.98316445e-05, 0.26330927, -0.964711607, -7.68547761e-06, 0.964711607, 0.26330927),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

function Shrek()
	Attack = true
	NeutralAnims = false
	local oWS = WalkSpeed
	for i = 0, 2, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CFrame.new(-0.0045717326, 0.0650117323, -0.292746365, 0.999985039, -0.0054067187, -0.000930163078, 0.00540099945, 0.940456271, 0.339872152, -0.000962814316, -0.339872032, 0.940471232),Alpha)
		LH.C0 = LH.C0:lerp(CFrame.new(-0.497873425, -1.08922517, -0.0665005744, 0.991378665, 0.00540100131, 0.130918339, 0.0394607596, 0.940456986, -0.337614775, -0.124946497, 0.339870125, 0.932135701),Alpha)
		RH.C0 = RH.C0:lerp(CFrame.new(0.497141123, -1.09262908, -0.0732582211, 0.991080165, 0.00540100131, -0.133158669, -0.0502922162, 0.940456986, -0.336171925, 0.123414315, 0.339870125, 0.932339728),Alpha)
		LS.C0 = LS.C0:lerp(CFrame.new(-1.01297855, 0.687084556, -0.109048009, 0.909904242, -0.414624929, -0.0126772588, -0.341911346, -0.732326984, -0.588892102, 0.234885365, 0.540169775, -0.808112383),Alpha)
		RS.C0 = RS.C0:lerp(CFrame.new(1.10972738, 0.686874747, -0.142190307, 0.902195573, 0.431141198, -0.012677161, 0.341730058, -0.732411623, -0.588892102, -0.263180494, 0.526963592, -0.808112264),Alpha)
		NK.C0 = NK.C0:lerp(CFrame.new(1.14651302e-05, 1.49894774, -0.0143921971, 1.00000012, 1.31642446e-06, -5.17815351e-07, -1.28056854e-06, 0.997964919, 0.0637671649, 5.99771738e-07, -0.0637671053, 0.997964978),Alpha)
	end
	WalkSpeed = 0
	Sound(Head,368794903,1.2,10,false,true,true)
	local wo = IN("Model",Effects)

	for i = 1, 3 do
		local wat = 12.5+(i*2)
		local screamPart = Part(wo,BrickColor.new'Pearl',Enum.Material.Neon,V3.N(1,1,1),Head.CFrame,false,false)
		screamPart.Transparency = .6+(i/10)
		Mesh(screamPart,Enum.MeshType.Sphere,"","",V3.N(wat,wat,wat))
		Weld(screamPart,Torso)
	end

	for i = 0, 8, 0.1 do
		swait()
		AOEDamage(Torso.CFrame.p,20,{
			MinimumDamage=5,
			MaximumDamage=10
		})
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CFrame.new(0.00617184862, -0.15, 0.395316333, 0.999986708, 0.00508808438, -0.000884585083, -0.00509300316, 0.943203092, -0.332178056, -0.000855805352, 0.332178146, 0.943216264)*CF.A(M.R(20),0,0),Alpha)
		LH.C0 = LH.C0:lerp(CFrame.new(-0.497282684, -1.06256902, -0.0290378034, 0.999878228, -0.00509300316, 0.0147562362, -9.85493534e-05, 0.943203092, 0.332217097, -0.0156101063, -0.332178056, 0.943087518)*CF.A(M.R(-20),0,0),Alpha)
		RH.C0 = RH.C0:lerp(CFrame.new(0.497732252, -1.05967009, -0.03568241, 0.999878228, -0.00509300316, 0.0147562362, -9.85493534e-05, 0.943203092, 0.332217097, -0.0156101063, -0.332178056, 0.943087518)*CF.A(M.R(-20),0,0),Alpha)
		LS.C0 = LS.C0:lerp(CFrame.new(-1.42849481, 0.494048148, -0.00801739097, 0.98822248, 0.134164602, 0.0735954121, -0.152104512, 0.808569551, 0.568401217, 0.0167523213, -0.572901011, 0.819453418),Alpha)
		RS.C0 = RS.C0:lerp(CFrame.new(1.41312766, 0.523678839, 0.0325531065, 0.980119586, -0.184282064, 0.0735261068, 0.110644385, 0.815263927, 0.568421364, -0.164693028, -0.548985541, 0.81944561),Alpha)
		NK.C0 = NK.C0:lerp(CFrame.new(9.04871195e-06, 1.49893618, -0.0143969432, 1.00000012, 9.62987542e-07, -2.71946192e-07, -9.43895429e-07, 0.997964919, 0.0637682378, 3.31550837e-07, -0.063768208, 0.997964799),Alpha)
	end
	wo:breakJoints()
	wo:destroy()
	WalkSpeed = oWS
	Attack = false
	NeutralAnims = true
end

function NeckSnap(target)
	if(target)then
		local torso = GetTorso(target)
		local hum = target:FindFirstChildOfClass'Humanoid'
		local hed = target:FindFirstChild'Head'
		if(torso and hum and hum.Health > 0 and hed)then
			local oWS = WalkSpeed
			local oPar = target.Parent
			local originalpos = Root.CFrame
			WalkSpeed = 0
			Hum.JumpPower = 0
			Attack = true
			NeutralAnims = false
			Root.Anchored = true
			torso.Anchored = true
			target.Parent = Char
			Hum.AutoRotate = false
			Root.CFrame = torso.CFrame*CF.N(-0.54454422, 0, 0.987496376)
			for _,v in next, torso:children() do
				if(v:IsA'JointInstance' and (v.Part0 == hed or v.Part1 == hed))then
					v:destroy()
				end
			end
			hed:breakJoints()
			local weld = NewInstance('Motor',torso,{Part0=hed,Part1=torso,C0=CF.N(0,-1.5,0)})
			for i = 0, 1, 0.1 do
				swait()
				local Alpha = .3
				RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990816116, 0.0216189735, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990978718, 0.0154631268, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-0.763917506, 0.783056259, -0.756683111, 0.675138593, -0.737685442, 0.00284584239, 0.140656561, 0.124941669, -0.982143223, 0.724157274, 0.663483143, 0.188113257),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.23871374, 1.09544897, -0.196351975, 0.766011953, 0.365654767, -0.528698623, -0.105766296, -0.739559352, -0.664729595, -0.634065628, 0.565109432, -0.527837396),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(1.00737725e-05, 1.4989512, -0.0144016817, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			end
			Sound(hed,1093102664,1,5,false,true,true)
			for i = 0, 1.3, 0.1 do
				swait()
				local Alpha = .3
				weld.C0 = weld.C0:lerp(CF.N(0,-1.5,0)*CF.A(0,M.R(-90),0),Alpha)
				RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990818024, 0.0216189846, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990980625, 0.0154631399, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.38228214, 0.484847993, -0.0603635609, 0.424681932, 0.905338109, 0.00285495515, -0.169125155, 0.0824314952, -0.982141495, -0.889405489, 0.41661495, 0.18812263),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.40680802, 0.48904568, -0.02736184, 0.441890627, -0.897064447, 0.00284484075, 0.169923306, 0.0805888921, -0.982156575, 0.8808285, 0.43448925, 0.188043654),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(1.00737716e-05, 1.49894726, -0.014402397, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			end
			target.Parent = oPar
			target:breakJoints()
			WalkSpeed = oWS
			Hum.JumpPower = 50
			Hum.AutoRotate = true
			Root.Anchored = false
			torso.Anchored = false
			Attack = false
			NeutralAnims = true
		end
	end
end

function AttackOne()
	Attack = true
	NeutralAnims = false
	for i = 0, .7, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.054845117, 0.00628340431, 0.0621978641, 0.574560821, -0.00514742406, -0.818445683, 1.76018864e-06, 0.99998033, -0.00628790678, 0.818461895, 0.00361134461, 0.574549437),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.525948346, -0.994591057, 0.0135081597, 0.989666939, 0.0856333151, 0.115006924, -0.0869238526, 0.996195495, 0.00624422729, -0.114034653, -0.0161765479, 0.993345082),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.487148911, -0.967346072, -0.0260838568, 0.964277864, -0.0686885938, 0.255832553, -0.00166595122, 0.964203477, 0.265158683, -0.264888048, -0.256112814, 0.92964536),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.38879275, 0.498546124, -0.255748421, 0.692717075, 0.721134841, 0.0103802728, 0.00202227081, 0.0124506345, -0.999920607, -0.721206725, 0.692682922, 0.00716643687),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.27866459, 0.504911065, -0.181807131, 0.763874948, -0.645362377, -0.00163397193, -0.0634241104, -0.0725510716, -0.995346248, 0.642240286, 0.760423601, -0.0963514596),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-0.0864869878, 1.49901688, -0.00313834194, 0.57456094, -0.0470548049, 0.817108035, -0.00514778076, 0.998118699, 0.0610983856, -0.818445623, -0.0393110402, 0.573237658),Alpha)
	end
	Sound(RArm,200632136,1.1,5,false,true,true)
	for i = 0, .9, 0.1 do
		swait()
		local Alpha = .3
		AOEDamage(RArm.CFrame.p,2,{MinimumDamage=10,MaximumDamage=30})
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0895246193, 0.00628795894, -0.0240665041, 0.667355478, 0.00468144845, 0.744724631, -1.60177922e-06, 0.99998033, -0.00628458662, -0.744739354, 0.0041928608, 0.667342305),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.525933743, -0.994594276, 0.0135074947, 0.995298743, 0.0856334865, -0.0452488065, -0.0847965032, 0.996195495, 0.0201073457, 0.0467984378, -0.0161758773, 0.998773336),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.490905643, -0.74434638, -0.358290195, 0.993401766, -0.0489627272, -0.103709608, 0.0897386894, 0.894942641, 0.437063992, 0.0714142919, -0.443486929, 0.893431306),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.34781098, 0.451429009, 0.184345022, 0.920896769, 0.211902812, 0.327179492, -0.00245033321, 0.842468321, -0.538740575, -0.389798939, 0.495322734, 0.776345491),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.33741677, 0.579409122, -0.335710943, 0.71467489, -0.698394477, 0.0385371894, -0.0347292982, -0.0904589221, -0.995294571, 0.698594153, 0.709973574, -0.0889034569),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(0.0455316827, 1.49947691, 0.069996126, 0.667355359, 0.0428168029, -0.743507743, 0.00468109129, 0.99808526, 0.0616789386, 0.744724751, -0.0446421988, 0.665876985),Alpha)
	end
	Combo = 2
	Attack = false
	NeutralAnims = true
end

function AttackTwo()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.00337019563, 0.00628272956, -0.00105122454, 0.788301051, 0.00386909139, 0.615277588, -1.32338778e-06, 0.99998033, -0.00628654705, -0.615289807, 0.00495487731, 0.788285434),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.370244205, -1.06356883, -0.0345072895, 0.88316524, 0.227487147, 0.41020599, -0.259257317, 0.965541184, 0.0227174684, -0.390902787, -0.126412138, 0.911709964),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.39778316, -1.07560706, -0.0971514285, 0.900898933, -0.0766149312, -0.427213579, 0.151964575, 0.977673352, 0.145127282, 0.406556368, -0.195666283, 0.892427385),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.47616029, 0.512279212, 0.0670655966, 0.904187679, -0.427135438, 0.00023345463, 0.00958644785, 0.0197467823, -0.999759197, 0.427027881, 0.903972089, 0.0219495054),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.33361411, 0.488021076, -0.300545812, 0.00661067665, -0.543416262, 0.839437485, 0.976997852, -0.175422177, -0.121254832, 0.213147745, 0.820930004, 0.529756606)*CF.A(0,M.R(-90),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-0.000233855098, 1.49894583, -0.0145844966, 0.788300931, 0.0353745371, -0.614272296, 0.0038687347, 0.998041451, 0.062439695, 0.615277767, -0.0515977256, 0.786619961),Alpha)
	end	
	Sound(LArm,200632136,.9,5,false,true,true)
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		AOEDamage(LArm.CFrame.p,2,{MinimumDamage=10,MaximumDamage=30})
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0139055764, 0.00628619827, -0.0431878939, 0.736094832, -0.0042554969, -0.676865041, 1.4556681e-06, 0.99998033, -0.00628536195, 0.676878333, 0.00462563755, 0.736080408),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.370245337, -1.06356549, -0.0345049649, 0.883166075, 0.227488101, 0.410203636, -0.25925675, 0.965541363, 0.0227144919, -0.390901268, -0.126408711, 0.911711276),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.397780299, -1.07560635, -0.0971318483, 0.900898337, -0.076615192, -0.427214652, 0.151964024, 0.977673769, 0.145124823, 0.406557709, -0.195663959, 0.892427325),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.54785693, 0.502721965, -0.369121343, 0.640384734, 0.768054307, 9.36477445e-05, -0.0167029109, 0.0140483743, -0.999761999, -0.767872751, 0.640230715, 0.0218251087),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.41005266, 0.394677043, -0.101526827, 0.621816397, -0.730075538, 0.283432782, 0.783004642, 0.586830258, -0.206238553, -0.0157571733, 0.350171626, 0.93655318)*CF.A(0,M.R(-90),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(0.0361058414, 1.49909592, 0.00928576291, 0.736094952, -0.0389148258, 0.67575866, -0.00425585406, 0.998060346, 0.0621110015, -0.676864862, -0.0485955328, 0.7345016),Alpha)
	end
	Combo = 3
	Attack = false
	NeutralAnims = true
end

function AttackThree()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674868, -5.34626452e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496486187, -0.990816116, 0.0216190033, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990978718, 0.0154631268, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12213016, 0.47289753, -0.302224725, 0.912795186, -0.408417523, -7.55176477e-10, 0.00256825075, 0.00573992962, -0.999980211, 0.408409536, 0.912777245, 0.00628829934),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.11283636, 0.472678095, -0.337120384, 0.899599433, 0.436715961, -7.55176477e-10, -0.00274620112, 0.00565694971, -0.999980211, -0.436707377, 0.89958173, 0.00628829934),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(8.16642296e-06, 1.49894738, -0.0144004971, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
	end
	--for a = 1, 3 do
	local a = 2
	coroutine.wrap(function()
		for i = 5,45,10 do
			local hite = Instance.new("Part",Char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.Material = "Neon"
			hite.Size = V3.N(1, 1, 1)
			hite.Transparency = 1
			hite.CFrame = (Root.CFrame + Root.CFrame.lookVector)*CF.A(0,M.R(90+(a*45)),0)*CF.N(0,0,i)
			CamShakeAOE(hite.CFrame.p,10,30,250)
			NoobySphere2(3,'Multiply',hite.CFrame,V3.N(0,0,0),.15,Core2.Color)
			NoobySphere2(6,'Multiply',hite.CFrame,V3.N(0,0,0),.3,Core2.Color)
			for i = 1, 2 do
				NoobySphere(2,.2,'Multiply',Root.CFrame*CF.N(0,-.5,-.5)*CF.A(M.RRNG(-20,20),M.RRNG(-20,20),M.RRNG(-20,20)),V3.N(.5,.5,5),-.005,Core2.Color,0)			
			end
			for i = 1, 5 do
				NoobySphere(2.25,.6,'Multiply',hite.CFrame*CF.N(0,0,0)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(2,2,2),0,Core2.Color,0)
			end
			AOEDamage(hite.CFrame.p,10,{MinimumDamage=25,MaximumDamage=45})
			Sound(hite,183763506,1,5,false,true,true)
			S.Debris:AddItem(hite,2)
			swait()
		end
	end)()
	--end
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.00691798097, -0.0495741703, 0.443018734, 0.999998093, -0.00196288247, -0.000110176392, 0.00196200004, 0.992848635, 0.119364031, -0.000124909915, -0.119364008, 0.992850542),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497228384, -0.946920514, -0.0261252522, 0.999878228, 0.0041074818, 0.0150607219, -9.9174933e-05, 0.966415524, -0.256984442, -0.0156104742, 0.25695163, 0.966298223),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497788221, -0.949530363, -0.0326310396, 0.999878228, 0.0041074818, 0.0150607219, -9.9174933e-05, 0.966415524, -0.256984442, -0.0156104742, 0.25695163, 0.966298223),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.43487072, 0.476260573, 0.232709944, -0.586293817, 0.810098529, 9.3865674e-07, -0.00509618223, -0.00368710607, -0.999980271, -0.810082495, -0.586282253, 0.00629013777),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.44212484, 0.475975186, 0.187793851, -0.560718656, -0.828006506, -2.90002208e-06, 0.00520995259, -0.00352462381, -0.999980271, 0.827990055, -0.56070751, 0.00629019737),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(9.53681956e-06, 1.49895513, -0.0144005343, 1.00000012, 0, 9.31322575e-10, 1.16415322e-10, 0.99796474, 0.0637698025, -9.31322575e-10, -0.0637697875, 0.997964621),Alpha)
	end
	Combo = 1
	Attack = false
	NeutralAnims = true
end


local WingSine = 0
local WingChange = 1

function SolitudeMode()
	Attack = true
	NeutralAnims = false
	local Sin = 0
	MusicID = 1564523997
	Pitch = 1
	WalkSpeed = 0
	Sound(Core2,136007472,1.25,2.5,false,true,true)
	for i = 0, 4, 0.1 do
		swait()
		NoobySphere(2.5,-1.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(3.5,3.5,45),-.035,Core2.Color,100)
		Sin = Sin + 5
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00700476859, 0.0667984039, -0.448462069, 0.999972343, -0.00723911775, -0.00172879919, 0.00722799823, 0.88917774, 0.457504779, -0.00177471992, -0.457504541, 0.889205575),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497889668, -1.14359522, -0.0677340925, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497117043, -1.14809179, -0.0749855936, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.20745349, 0.562693655, 0.156515986, 0.841866791, -0.539501786, -0.014077506, -0.490290582, -0.753652692, -0.43774724, 0.225555882, 0.375426948, -0.898987949)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.17680144, 0.613272369, 0.0997506529, 0.834507108, 0.550817847, -0.0140647329, 0.49015516, -0.753777146, -0.437684804, -0.251686275, 0.358357221, -0.899018526)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(6.50798393e-06, 1.53005648, -0.348988175, 1.00000012, 2.40840018e-06, -1.19656324e-05, 5.68898395e-06, 0.775360823, 0.631518543, 1.07986853e-05, -0.631518602, 0.775360942)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
	end
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Black' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Black' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Black' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Black' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Black' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,0,0) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,0,0) end)
	WalkSpeed = 16
	Mode = 1
	Core2.BrickColor = BrickColor.new'Black'
	Core2.Material = Enum.Material.Neon
	Sound(Root,"206082327",1,2.5,false,true,true)
	Sound(Root,"847061203",1,5,false,true,true)
	Sound(Root,"239000203",1,2.5,false,true,true)
	Sound(Root,"579687077",.75,2.5,false,true,true)
	RecolorTextAndRename("Solitude",Color3.new(0,0,0),Color3.new(1,1,1))
	NoobySphere2(2.5,'Multiply',Core2.CFrame,V3.N(0,0,0),1,Core2.BrickColor)
	for i = 1, 24 do
		NoobyBlock(1,M.RNG(20,100)/100,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(2,2,2),.04,Core2.Color,0,true)
	end
	for i = 0, 15 do
		NoobySphere(3,-.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.5,.5,25),-.04,Core2.Color,0)
	end
	for i = 0, 1.4, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.0104959598, -0.113952652, 0.672263861, 0.999963522, 0.00820299331, -0.0023882892, -0.00821700692, 0.846846819, -0.531773448, -0.00233961921, 0.531773746, 0.846883237),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49749428, -1.06169748, -0.0426189601, 0.999878228, -0.00744201383, 0.013721575, -0.000100045589, 0.875963986, 0.482376754, -0.0156094572, -0.482319295, 0.875856459),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498449236, -1.1497941, 0.0108022094, 0.999878228, -0.0120362351, 0.009939529, -0.000100045589, 0.631795883, 0.775134981, -0.0156094572, -0.775041461, 0.631717622),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12307608, 0.484921068, 0.092245549, 0.865161359, 0.501252413, -0.0155520458, 0.497926384, -0.862286389, -0.092366755, -0.059709385, 0.07216838, -0.995603561),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.37669122, 0.484069884, 0.0531393886, 0.866546988, -0.498853445, -0.0155524863, -0.49802509, -0.862227678, -0.0923835635, 0.032676056, 0.0878001451, -0.995602131),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.14440181e-05, 1.49895036, -0.0144141242, 1.00000012, 0, -9.31322575e-10, 0, 0.99796474, 0.0637694895, -9.31322575e-10, -0.0637694895, 0.99796468),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

function PureMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	WalkSpeed = 16
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(0,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(0,1,1) end)
	RecolorTextAndRename("Clarity",C3.N(1,1,1),BrickColor.new'Pastel Blue'.Color)
	MusicID = 1539245059
	Pitch = 1
	Mode = 2
	Core2.BrickColor = BrickColor.new'Pastel Blue'	
	Core2.Material = Enum.Material.Neon
end

function GlitchMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 0 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 1 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 1 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 1 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'White' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,1,1) end)
	WalkSpeed = 16
	RecolorTextAndRename("Glitchy",C3.N(1,1,1),C3.N(1,1,1))
	MusicID = 1274310715
	Pitch = .93
	Mode = 3
	Core2.BrickColor = BrickColor.new'Dark stone grey'
	Core2.Material = Enum.Material.DiamondPlate	
end	

function StressMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .25 v.BrickColor = BrickColor.new'Crimson' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.Color = C3.RGB(16,16,16) end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Crimson' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Crimson' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Crimson' end
	end
	WalkSpeed = 14
	RecolorTextAndRename("Stress",C3.N(.6,0,0),C3.N(0,0,0))
	MusicID = 614032233
	Pitch = 1
	Mode = 4
	Core2.BrickColor = BrickColor.new'Really red'
	Core2.Material = Enum.Material.Neon	
end	

function JusticeMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Institutional white' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,1,1) end)
	WalkSpeed = 50
	RecolorTextAndRename("Justice",C3.N(1,1,1),C3.N(0,0,0))
	MusicID = 1102271169
	Pitch = 1
	Mode = 5
	Core2.BrickColor = BrickColor.new'White'
	Core2.Material = Enum.Material.Neon	
end	

function RiddleMeThis()
	Attack = true
	NeutralAnims = false
	WalkSpeed = 0
	MusicID = 1420353940
	Pitch = 1
	Muted = true
	repeat swait() until Music.IsLoaded	
	Muted = false
	Music.TimePosition = 0
	Chat('Riddle me this..')
	for i = 0,14,.1 do
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496486187, -0.990816116, 0.0216199569, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990978718, 0.0154640805, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.15619826, 0.410764694, 0.308931053, 0.862226903, -0.506325424, 0.0141164251, 0.451236814, 0.780479908, 0.432708263, -0.230108798, -0.366722882, 0.901423633),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.48984146, 0.433965802, -0.137121022, 0.754978359, -0.655723989, -0.00581999123, -0.244246826, -0.272958666, -0.930503726, 0.608564973, 0.703931689, -0.366236359),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(8.11554492e-06, 1.49894369, -0.0144015253, 0.931422114, -1.17415329e-05, -0.363940746, 0.0232203864, 0.997964501, 0.0593950115, 0.363199264, -0.0637726635, 0.929526567),Alpha)
		swait()
	end
	Chat('Riddle me that..')
	for i = 0,12,.1 do
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674868, -5.34626452e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990818024, 0.0216189846, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990980625, 0.0154631399, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.25402236, 0.431008309, 0.117451549, 0.884577334, 0.388638854, 0.257842481, 0.312682211, -0.0839776248, -0.946138322, -0.346053123, 0.917555273, -0.195805177),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.22954941, 0.384757012, 0.168471783, 0.915931404, 0.401068091, 0.0146304797, -0.379809946, 0.85445267, 0.354478538, 0.129668966, -0.330234885, 0.934949815),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(8.37445259e-06, 1.49894357, -0.0144015923, 0.920970619, 2.08709389e-06, 0.389632136, -0.0248486493, 0.99796474, 0.058729209, -0.388839096, -0.063769713, 0.919096231),Alpha)
		swait()	
	end
	Chat("Who's afraid of the big black..")
	for i = 0,16,.1 do
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00438984111, 0.0221795738, -0.281239897, 0.999988556, -0.00473595224, -0.000703255646, 0.00473099947, 0.954816878, 0.297157228, -0.000735841691, -0.297157168, 0.954828322),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497070849, -1.04715037, -0.0156083405, 0.999878228, 0.00473099947, 0.0148762148, -9.61141777e-05, 0.954816878, -0.297194898, -0.0156100877, 0.297157228, 0.954700947),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49794969, -1.05015182, -0.0222227573, 0.999878228, 0.00473099947, 0.0148762148, -9.61141777e-05, 0.954816878, -0.297194898, -0.0156100877, 0.297157228, 0.954700947),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.32246351, 0.253595859, 0.199904889, 0.862232804, -0.506315708, 0.0141151678, 0.451225579, 0.780480325, 0.432719588, -0.230109304, -0.366735876, 0.90141809),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.33073413, 0.290129036, 0.183640629, 0.915928423, 0.401075214, 0.0146333817, -0.379820168, 0.854456067, 0.354459614, 0.129661351, -0.330217659, 0.934956849),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.58162902e-06, 1.5248462, -0.171738505, 1.00000012, -7.59866089e-06, 1.38636678e-05, -3.15252692e-07, 0.867144346, 0.498057216, -1.58054754e-05, -0.498057246, 0.867144227),Alpha)
		swait()
	end
	for i = 0, .7, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00700476859, 0.0667984039, -0.448462069, 0.999972343, -0.00723911775, -0.00172879919, 0.00722799823, 0.88917774, 0.457504779, -0.00177471992, -0.457504541, 0.889205575),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497889668, -1.14359522, -0.0677340925, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497117043, -1.14809179, -0.0749855936, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.20745349, 0.562693655, 0.156515986, 0.841866791, -0.539501786, -0.014077506, -0.490290582, -0.753652692, -0.43774724, 0.225555882, 0.375426948, -0.898987949),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.17680144, 0.613272369, 0.0997506529, 0.834507108, 0.550817847, -0.0140647329, 0.49015516, -0.753777146, -0.437684804, -0.251686275, 0.358357221, -0.899018526),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(6.50798393e-06, 1.53005648, -0.348988175, 1.00000012, 2.40840018e-06, -1.19656324e-05, 5.68898395e-06, 0.775360823, 0.631518543, 1.07986853e-05, -0.631518602, 0.775360942),Alpha)
	end

	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .5 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .5 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Really black' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = BrickColor.new'Black'.Color end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = BrickColor.new'Black'.Color end)
	WalkSpeed = 50
	RecolorTextAndRename("The Big Black",BrickColor.new'Really black'.Color,C3.N(1,1,1))
	Core2.BrickColor = BrickColor.new'Really black'
	Core2.Material = Enum.Material.Neon	
	Mode = 666666666666
	Sound(Root,"206082327",1,2.5,false,true,true)
	Sound(Root,"847061203",1,5,false,true,true)
	Sound(Root,"239000203",1,2.5,false,true,true)
	Sound(Root,"579687077",.75,2.5,false,true,true)
	NoobySphere2(2.5,'Multiply',Core2.CFrame,V3.N(0,0,0),1,Core2.BrickColor)
	for i = 1, 24 do
		NoobyBlock(1,M.RNG(20,100)/100,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(2,2,2),.04,Core2.Color,0,true)
	end
	for i = 0, 15 do
		NoobySphere(3,-.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.5,.5,25),-.04,Core2.Color,0)
	end
	for i = 0, .7, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.0104959598, -0.113952652, 0.672263861, 0.999963522, 0.00820299331, -0.0023882892, -0.00821700692, 0.846846819, -0.531773448, -0.00233961921, 0.531773746, 0.846883237),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49749428, -1.06169748, -0.0426189601, 0.999878228, -0.00744201383, 0.013721575, -0.000100045589, 0.875963986, 0.482376754, -0.0156094572, -0.482319295, 0.875856459),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498449236, -1.1497941, 0.0108022094, 0.999878228, -0.0120362351, 0.009939529, -0.000100045589, 0.631795883, 0.775134981, -0.0156094572, -0.775041461, 0.631717622),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12307608, 0.484921068, 0.092245549, 0.865161359, 0.501252413, -0.0155520458, 0.497926384, -0.862286389, -0.092366755, -0.059709385, 0.07216838, -0.995603561),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.37669122, 0.484069884, 0.0531393886, 0.866546988, -0.498853445, -0.0155524863, -0.49802509, -0.862227678, -0.0923835635, 0.032676056, 0.0878001451, -0.995602131),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.14440181e-05, 1.49895036, -0.0144141242, 1.00000012, 0, -9.31322575e-10, 0, 0.99796474, 0.0637694895, -9.31322575e-10, -0.0637694895, 0.99796468),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

--// Wrap it all up \\--

function KeyPress(code)
	if(code == Enum.KeyCode.One and Mode ~= 1)then
		SolitudeMode()
	elseif(code == Enum.KeyCode.Two and Mode ~= 2)then
		PureMode()
	elseif(code == Enum.KeyCode.Three and Mode ~= 3)then
		GlitchMode()
	elseif(code == Enum.KeyCode.Four and Mode ~= 4)then
		StressMode()
	elseif(code == Enum.KeyCode.Five and Mode ~= 5)then
		JusticeMode()
		-- Transformations
	elseif(code == Enum.KeyCode.T)then
		if(Mode == 1)then
			RiddleMeThis()
		end
		-- Toggle player attacking
	elseif(code == Enum.KeyCode.Semicolon)then
		DontAttackPlayers = not DontAttackPlayers
		Chat(DontAttackPlayers and "You can no longer attack players" or "You can now attack players")
		-- Attacks
	elseif(code == Enum.KeyCode.Z)then
		if(Mode == 1 or Mode == 666666666666)then
			if(not UIS.TouchEnabled)then NeckSnap((Mouse.Target and Mouse.Target.Parent)) else warn("Tap someone, to snap their neck") MobileNeckSnap() end
		elseif(Mode == 2)then
			PureBomb()
		elseif(Mode == 3)then
			ClickGlitch()
		elseif(Mode == 4)then
			Shrek()
		elseif(Mode == 5)then
			Aeroplane()
		end
	end
end

function AttackCombo()
	if(Combo == 1)then AttackOne() elseif(Combo == 2)then AttackTwo() elseif(Combo == 3)then AttackThree() end
end

UIS.InputBegan:connect(function(io,gpe)
	if(Attack)then return end
	if(not gpe)then
		local code = io.KeyCode;
		if(io.UserInputType == Enum.UserInputType.Keyboard)then
			KeyPress(code)
		elseif(io.UserInputType == Enum.UserInputType.MouseButton1)then
			AttackCombo()
		end
	end
end)


coroutine.wrap(function()
	-- AURAS
	while true do		
		if(Mode == 5)then
			NoobySphere(5,0.15,"Multiply",Root.CFrame*CF.N(M.RNG(-5,5),-6,M.RNG(-5,5))*CF.A(M.R(90),0,0),V3.N(1.5,1.5,10),-0.015,BrickColor.new'White',0)
		elseif(Mode == 666666666666)then
			NoobySphere(5,math.random(25,75)/100,"Multiply",Root.CFrame*CF.N(M.RNG(-15,15),-10,M.RNG(-15,15))*CF.A(M.R(90),0,0)*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),V3.N(.75,.75,15),.005,Core2.BrickColor,0)			
		end
		if(Mode == 666666666666)then
			NoobySphere(5,math.random(75,150)/100,"Multiply",Root.CFrame*CF.N(M.RNG(-35,35),-10,M.RNG(-35,35))*CF.A(M.R(90),0,0)*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),V3.N(.75,.75,25),.005,Core2.BrickColor,0)					
		end

		swait()
	end	
end)()

while true do
	swait()
	Sine = Sine + Change
	WingSine = WingSine + WingChange
	if(Hue > 360)then Hue = 0 end
	Hue = Hue + 1

	if(not Music or not Music.Parent)then
		local tPos = 0;
		if(Music)then tPos = Music.TimePosition; Music:Stop(); Music:Destroy(); end
		Music = Sound(Char,MusicID,1,3,true,false,true)
		Music.Name = 'Music'
		Music.TimePosition = tPos;
	end
	Music.SoundId = "rbxassetid://"..MusicID
	Music.Parent = Char
	Music.Pitch = Pitch
	Music.Volume = 2
	if(not Muted)then
		Music:Resume()
	else
		Music:Pause()
	end

	if(God)then
		Hum.MaxHealth = 1e100
		Hum.Health = 1e100
		if(not Char:FindFirstChildOfClass'ForceField')then IN("ForceField",Char).Visible = false end
		Hum.Name = M.RNG()*100
	end

	local hitfloor,posfloor,norm = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char)

	if(Mode == 3)then
		for _,v in next, LWing:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end
		for _,v in next, RWing:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end
		for _,v in next, LWingEXT:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end
		for _,v in next, RWingEXT:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end

		local what1 = M.RNG()
		local what2 = M.RNG()
		local what3 = M.RNG()
		local what4 = M.RNG()
		Core2.Color = C3.N(what1,what1,what1)

		for _,v in next, Halo:children() do
			if(v:IsA'BasePart')then
				v.Color = C3.N(what1,what1,what1)
			end
		end

		text.TextStrokeColor3 = C3.N(what2,what2,what2)
		text.TextColor3 = C3.N(what3,what3,what3)
		pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(what4,what4,what4) end)
		pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(what4,what4,what4) end)
	elseif(Mode == 4)then
		for _,v in next, LWing:children() do
			local what = M.RNG()*.5
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,0,0)
			end
		end
		for _,v in next, LWingEXT:children() do
			local what = M.RNG()*.5
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,0,0)
			end
		end

		local what1 = M.RNG()*.5
		local what2 = M.RNG()*.5
		local what3 = M.RNG()*.5
		local what4 = M.RNG()*.5
		Core2.Color = C3.N(what1,0,0)

		for _,v in next, Halo:children() do
			if(v:IsA'BasePart')then
				v.Color = C3.N(what1,0,0)
			end
		end

		text.TextStrokeColor3 = C3.N(what2,0,0)
		text.TextColor3 = C3.N(what3,0,0)
		pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(what4,0,0) end)
		pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(what4,0,0) end)
	end

	LWingWelds[1].C0 = LWingWelds[1].C0:lerp(CF.N(0,0,2.25)*CF.A(0,M.R(-90),0)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(12.5+5*M.C(WingSine/32))),.1)
	LWingWelds[2].C0 = LWingWelds[2].C0:lerp(CF.N(0,1,3.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(25+7.5*M.C(WingSine/32))),.1)
	LWingWelds[3].C0 = LWingWelds[3].C0:lerp(CF.N(0,2,4.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(37.5+10*M.C(WingSine/32))),.1)
	LWingWelds[4].C0 = LWingWelds[4].C0:lerp(CF.N(0,3,5.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(20+25*M.C(WingSine/32)),0,M.R(50+12.5*M.C(WingSine/32))),.1)
	LWingWelds[5].C0 = LWingWelds[5].C0:lerp(CF.N(0,4,6.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(25+30*M.C(WingSine/32)),0,M.R(62.5+15*M.C(WingSine/32))),.1)
	LWingWelds[6].C0 = LWingWelds[6].C0:lerp(CF.N(0,5,7.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(35+40*M.C(WingSine/32)),0,M.R(75+17.5*M.C(WingSine/32))),.1)

	RWingWelds[1].C0 = RWingWelds[1].C0:lerp(CF.N(0,0,-2.25)*CF.A(0,M.R(-90),0)*CF.A(M.R(5+10*M.C(WingSine/32)),0,-M.R(12.5+5*M.C(WingSine/32))),.1)
	RWingWelds[2].C0 = RWingWelds[2].C0:lerp(CF.N(0,1,-3.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(10+15*M.C(WingSine/32)),0,-M.R(25+7.5*M.C(WingSine/32))),.1)
	RWingWelds[3].C0 = RWingWelds[3].C0:lerp(CF.N(0,2,-4.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(15+20*M.C(WingSine/32)),0,-M.R(37.5+10*M.C(WingSine/32))),.1)
	RWingWelds[4].C0 = RWingWelds[4].C0:lerp(CF.N(0,3,-5.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(20+25*M.C(WingSine/32)),0,-M.R(50+12.5*M.C(WingSine/32))),.1)
	RWingWelds[5].C0 = RWingWelds[5].C0:lerp(CF.N(0,4,-6.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(25+30*M.C(WingSine/32)),0,-M.R(62.5+15*M.C(WingSine/32))),.1)
	RWingWelds[6].C0 = RWingWelds[6].C0:lerp(CF.N(0,5,-7.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(35+40*M.C(WingSine/32)),0,-M.R(75+17.5*M.C(WingSine/32))),.1)

	local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
	local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or not hitfloor and Root.Velocity.y < -1 and "Fall" or not hitfloor and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and (Hum.WalkSpeed < 24 and "Walk" or "Run") or hitfloor and "Idle")
	if(not Effects or not Effects.Parent)then
		Effects = IN("Model",Char)
		Effects.Name = "Effects"
	end																																																																																																		
	if(State == 'Run' and Mode ~= 5 and Mode ~= 10 and Mode ~= 666666666666)then
		local wsVal = 7 / (Hum.WalkSpeed/16)
		local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
		Change = 1

	elseif(State == 'Walk' and Mode ~= 5 and Mode ~= 10 and Mode ~= 666666666666)then
		local wsVal = 7 / (Hum.WalkSpeed/16)
		local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
		Change = 1
		if(Mode == 7)then
			RH.C1 = RH.C1:lerp(CF.N(0,1-.05*M.C(Sine/wsVal),0+.1*M.C(Sine/wsVal))*CF.A(M.R(8-0*M.C(Sine/wsVal))+-M.S(Sine/wsVal)/3,0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1+.05*M.C(Sine/wsVal),0-.1*M.C(Sine/wsVal))*CF.A(M.R(8+0*M.C(Sine/wsVal))+M.S(Sine/wsVal)/3,0,0),Alpha)
		else
			RH.C1 = RH.C1:lerp(CF.N(0,1-.1*M.C(Sine/wsVal),0+.2*M.C(Sine/wsVal))*CF.A(M.R(16-0*M.C(Sine/wsVal))+-M.S(Sine/wsVal)/1.75,0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1+.1*M.C(Sine/wsVal),0-.2*M.C(Sine/wsVal))*CF.A(M.R(16+0*M.C(Sine/wsVal))+M.S(Sine/wsVal)/1.75,0,0),Alpha)
		end
	else
		RH.C1 = RH.C1:lerp(CF.N(0,1,0),.2)
		LH.C1 = LH.C1:lerp(CF.N(0,1,0),.2)
	end	

	Hum.WalkSpeed = WalkSpeed
	if(NeutralAnims)then	
		if(State == 'Idle')then
			local Alpha = .1
			if(Mode == 1)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00779043138, -0.0846293643+.1*M.C(Sine/32), -0.204210758, 0.912902117, -0.00691865245, -0.408120036, 0.117574908, 0.961935759, 0.246689886, 0.390878439, -0.273188382, 0.87896657),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.587742627, -1.00122428-.1*M.C(Sine/32), -0.165018916, 0.860076427, 0.294745922, 0.416405559, -0.252913684, 0.955196917, -0.15373303, -0.443061411, 0.0269074962, 0.896087468),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.343915284, -1.07833397-.1*M.C(Sine/32), -0.0402937233, 0.964631855, -0.173768938, -0.198217094, 0.117325157, 0.956397653, -0.26746732, 0.236051857, 0.234751642, 0.942958832),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.39700282, 0.545769572, -0.00181379914, 0.907886505, 0.355485201, -0.222199559, -0.405204862, 0.880023003, -0.247727305, 0.107477367, 0.314944565, 0.943005204)*CF.A(0,M.R(16-8*M.C(Sine/32)),M.R(0+12*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.476125))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(0.903979659, 0.624733686, -0.396169931, 0.827836394, 0.560810268, -0.013374418, 0.472599089, -0.7100721, -0.521965444, -0.302220345, 0.42578119, -0.852861941)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(-0.0470906645, 1.53467083, -0.115898043, 0.906688511, -0.16142872, 0.389688164, -0.00265284558, 0.921666741, 0.387973785, -0.421792656, -0.352805078, 0.835236311)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
			elseif(Mode == 2)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674868+.1*M.C(Sine/32), -5.34626452e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496485978, -0.990816116-.1*M.C(Sine/32), 0.0216165781, 0.970629156, 7.27576055e-11, 0.240580648, -0.00151285366, 0.999980211, 0.00610364834, -0.240575925, -0.00628834311, 0.970610023),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.491330802, -1.06821454-.1*M.C(Sine/32), 0.0589520633, 0.986244023, 0.0538565964, -0.156276181, 0.00103943795, 0.943392873, 0.331676066, 0.165292785, -0.327276021, 0.930359602),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-0.787155986, 0.248306945, -0.683226228, 0.0398273654, -0.999169707, 0.00859495346, 0.554963291, 0.0149663882, -0.831740201, 0.830920994, 0.0378959104, 0.555098593)*CF.A(M.R(0+5*M.C(Sine/32)),0,0),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(0.787632346, 0.574486911, -0.794373989, 0.0789790228, 0.995851278, 0.0451963581, 0.631366551, -0.0148838377, -0.775341749, -0.771452367, 0.0897712111, -0.629922688)*CF.A(M.R(0+5*M.C(Sine/32)),0,0),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(8.16642296e-06, 1.49894726, -0.014402397, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			elseif(Mode == 3)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(0.022457514, 0.0062841149, -0.00324006379, 0.982301593, 0.00117789698, 0.187302738, -4.02951969e-07, 0.999980211, -0.00628649723, -0.187306449, 0.00617515948, 0.982282162),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.539962769, -1.00525093, -0.13583532, 0.998935044, -0.0434875898, 0.0154168755, 0.040365234, 0.985544145, 0.164539278, -0.0223494321, -0.163741738, 0.986250162),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498531163, -0.990978718, 0.01546143, 0.985106111, 0, -0.171948016, 0.00108131359, 0.999980211, 0.00619494682, 0.171944603, -0.00628860993, 0.98508662),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.42806315, 0.51039964, -0.00658199936, 0.990103781, 0.139778674, -0.0125195384, -0.139578417, 0.97154665, -0.191350713, -0.0145834237, 0.191204533, 0.981441915)*CF.A(0,0,M.R(0+6*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.42666709, 0.532186806, -0.134510398, 0.990944147, -0.126525059, 0.0449620783, 0.133282125, 0.967499852, -0.214895189, -0.0163111985, 0.218941733, 0.975601614)*CF.A(0,0,M.R(0-6*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.012802)),M.R(0-15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(2.28285789e-05, 1.49894154, -0.0143941939, 0.984171331, -0.0497024879, -0.170107797, 0.0760453045, 0.985445082, 0.152036116, 0.160075322, -0.162565485, 0.973626494)*CF.A(M.R(0+3*M.C(Sine/32)),0,M.R(0+6*M.C(Sine/32)))*CF.A(0,M.R(0+16*M.C(Sine/0.98172)),M.R(0+15*M.S(Sine/0.65142))),Alpha)
			elseif(Mode == 4)then
				Change = 1 
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00847404078, -0.131645858+.1*M.C(Sine/16), -0.542845488, 0.999965072, -0.00807052851, -0.00218774565, 0.00805599708, 0.85972774, 0.510689199, -0.00224066619, -0.51068902, 0.859762609),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496114701, -1.0144912-.1*M.C(Sine/16), 0.0453964472, 0.976583362, 0.00805600174, 0.214989081, 0.103035107, 0.859728813, -0.50025022, -0.188862324, 0.510687351, 0.838766694),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498885572, -1.01948476-.1*M.C(Sine/16), 0.0378640294, 0.997592449, 0.00805600174, -0.0688822865, -0.0420893468, 0.859728813, -0.509013772, 0.055119466, 0.510687351, 0.857997894),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.42592692, 0.493003547, -0.129623473, 0.987043619, 0.159894824, 0.0133710029, -0.130732149, 0.849730968, -0.51075089, -0.0930281729, 0.502385318, 0.859624803)*CF.A(0,0,M.R(0+6*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.817272)),M.R(0+15*M.S(Sine/0.9872346))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.1449033, 0.691183329, -0.239056498, 0.899715602, 0.434673697, 0.0396348648, 0.435808241, -0.899650335, -0.0264700353, 0.024151668, 0.0410887003, -0.998863578)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.87388399e-06, 1.43020797, -0.212884247, 1, -8.72649252e-07, -4.02983278e-06, 2.92807817e-06, 0.838354766, 0.545125127, 2.90293247e-06, -0.545125067, 0.838354826)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
			elseif(Mode == 5)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11, 1.2571125+.5*M.C(Sine/32), -3.51015478e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.436587602, -0.992619872, 0.0206923336, 0.99808234, 0.0599006973, 0.0156119233, -0.0600048117, 0.998178363, 0.00628757617, -0.0152068557, -0.0072123101, 0.999858439),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.481217712, -0.504008591, -0.8678087, 0.997120202, -0.0733773932, -0.0191624481, 0.0741236135, 0.889526427, 0.450830936, -0.0160352942, -0.450953096, 0.892403722),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.1*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(0,0,M.R(0+5*M.C(Sine/32))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.1*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(0,0,M.R(0-5*M.C(Sine/32))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			elseif(Mode == 666666666666)then
				Change = 1
				NoobySphere(4,.025,"Multiply",RArm.CFrame*CF.N(0,-1.25,0)*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.5,.5,.5),0,BrickColor.new'Black',0)
				RJ.C0 = clerp(RJ.C0,CFrame.new(7.0558559e-11, 1.61628103+.5*M.C(Sine/32), -3.05566937e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.473465502, -1.00430846, 0.0547358543, 0.996436775, 0.0789096355, 0.0297838245, -0.0829922184, 0.980262518, 0.179437637, -0.0150366053, -0.181270093, 0.983318448),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.500664473, -0.996896267, 0.0722374618, 0.994860828, -0.10125193, 0.00038037356, 0.0999543592, 0.982697129, 0.155934408, -0.0161624532, -0.155095011, 0.987767398),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.29428089, 0.420441031, 0.493041277, 0.816086888, -0.538787425, 0.209070042, 0.381859779, 0.774240494, 0.504712522, -0.43380329, -0.33205387, 0.837588906)*CF.A(0,0,M.R(0-5*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.36178303, 0.535555065, 0.0481818169, 0.959323943, -0.276642442, -0.0562722012, -0.281998605, -0.948367953, -0.145173192, -0.0132056763, 0.155136824, -0.98780489)*CF.A(0,0,M.R(0+5*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(0.0176411867, 1.49121404, -0.0637010336, 0.942441404, 0.0288463272, -0.333124816, 0.0213407781, 0.989051461, 0.146020114, 0.333689809, -0.144724563, 0.931507409)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+7.5*M.S(Sine/0.01278125))),Alpha)
			else			
				Change = .75
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.2*M.C(Sine/6),0)*CF.A(M.R(-5+5*M.C(Sine/12)),M.R(-10),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-5+5*M.C(Sine/12)),0,0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.A(0,0,M.R(-7-5*M.C(Sine/12))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(0,0,M.R(7+5*M.C(Sine/12))),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-.2*M.C(Sine/6),0)*CF.A(M.R(5-5*M.C(Sine/12)),M.R(10),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-.2*M.C(Sine/6),0)*CF.A(M.R(5-5*M.C(Sine/12)),M.R(-10),0),Alpha)
			end
			-- idle
		elseif(State == 'Run' and Mode ~= 5 and Mode ~= 10 and Mode ~= 666666666666)then
			local wsVal = 7 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
			RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-15+2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0-.3*M.S(Sine/wsVal))*CF.A(M.R(0+45*M.S(Sine/wsVal)),0,M.R(-5)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0+.3*M.S(Sine/wsVal))*CF.A(M.R(0-45*M.S(Sine/wsVal)),0,M.R(5)),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
		elseif(State == 'Walk' and Mode ~= 5 and Mode ~= 7 and Mode ~= 10 and Mode ~= 666666666666)then
			local wsVal = 7 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
			if(Mode == 4)then
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00847404078, -0.131645858-.1*M.C(Sine/(wsVal)), -0.542845488, 0.999965072, -0.00807052851, -0.00218774565, 0.00805599708, 0.85972774, 0.510689199, -0.00224066619, -0.51068902, 0.859762609),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496114701, -1.0144912+.1*M.C(Sine/(wsVal)), 0.0453964472, 0.976583362, 0.00805600174, 0.214989081, 0.103035107, 0.859728813, -0.50025022, -0.188862324, 0.510687351, 0.838766694),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498885572, -1.01948476+.1*M.C(Sine/(wsVal)), 0.0378640294, 0.997592449, 0.00805600174, -0.0688822865, -0.0420893468, 0.859728813, -0.509013772, 0.055119466, 0.510687351, 0.857997894),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.42592692, 0.493003547, -0.129623473, 0.987043619, 0.159894824, 0.0133710029, -0.130732149, 0.849730968, -0.51075089, -0.0930281729, 0.502385318, 0.859624803)*CF.A(M.R(0+15*M.C(Sine/wsVal)),0,0)*CF.A(0,M.R(0+4*M.C(Sine/0.817272)),M.R(0+15*M.S(Sine/0.9872346))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.1449033, 0.691183329, -0.239056498, 0.899715602, 0.434673697, 0.0396348648, 0.435808241, -0.899650335, -0.0264700353, 0.024151668, 0.0410887003, -0.998863578)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.87388399e-06, 1.43020797, -0.212884247, 1, -8.72649252e-07, -4.02983278e-06, 2.92807817e-06, 0.838354766, 0.545125127, 2.90293247e-06, -0.545125067, 0.838354826)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
			elseif(Mode == 696969)then
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00847404078, -0.131645858-.1*M.C(Sine/(wsVal)), -0.542845488, 0.999965072, -0.00807052851, -0.00218774565, 0.00805599708, 0.85972774, 0.510689199, -0.00224066619, -0.51068902, 0.859762609),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496114701, -1.0144912+.1*M.C(Sine/(wsVal)), 0.0453964472, 0.976583362, 0.00805600174, 0.214989081, 0.103035107, 0.859728813, -0.50025022, -0.188862324, 0.510687351, 0.838766694),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498885572, -1.01948476+.1*M.C(Sine/(wsVal)), 0.0378640294, 0.997592449, 0.00805600174, -0.0688822865, -0.0420893468, 0.859728813, -0.509013772, 0.055119466, 0.510687351, 0.857997894),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.3136189, 0.462844551+.1*M.C(Sine/wsVal), 0.00274867564, 0.929629087, -0.368184805, -0.015158236, -0.360420376, -0.899919868, -0.245441884, 0.0767267719, 0.23363328, -0.969292879)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.25962329, 0.543387234+.1*M.C(Sine/wsVal), 0.0906403661, 0.898135066, 0.439483941, -0.0144048491, 0.399390757, -0.829028964, -0.391405523, -0.183958456, 0.345781803, -0.920105577)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.87388399e-06, 1.43020797, -0.212884247, 1, -8.72649252e-07, -4.02983278e-06, 2.92807817e-06, 0.838354766, 0.545125127, 2.90293247e-06, -0.545125067, 0.838354826)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)

			elseif(Mode == 1)then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-5-2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.22*M.C(Sine/wsVal))*CF.A(M.R(0+37*M.C(Sine/wsVal)),0,M.R(-5+10*M.C(Sine/(wsVal/2))) ),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.2, 0.7, -0.396169931, 0.827836394, 0.560810268, -0.013374418, 0.472599089, -0.7100721, -0.521965444, -0.302220345, 0.42578119, -0.852861941)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			else 
				if(hitfloor and Mode == 9)then Effect{Material=Enum.Material.Neon,Effect='Fade',Mesh={MeshType=Enum.MeshType.Cylinder},Size=V3.N(.1,5,5),Frames=120,Color=BrickColor.new'Forest green',CFrame=CF.N(posfloor,posfloor+norm)*CF.A(0,M.R(90),0)} end
				RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-5-2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.22*M.C(Sine/wsVal))*CF.A(M.R(37*M.C(Sine/wsVal)),0,M.R(-5+10*M.C(Sine/(wsVal/2))) ),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,.22*M.C(Sine/wsVal))*CF.A(M.R(-37*M.C(Sine/wsVal)),0,M.R(5-10*M.C(Sine/(wsVal/2))) ),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			end
		elseif(State == 'Walk' and Mode == 7)then
			local wsVal = 7 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.3 * (Hum.WalkSpeed/8),1)
			RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-2.5-1.25*M.C(Sine/(wsVal/2))),M.R(4*M.C(Sine/wsVal)),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.11*M.C(Sine/wsVal))*CF.A(M.R(18.5*M.C(Sine/wsVal)),0,M.R(-2.5+5*M.C(Sine/(wsVal/2))) ),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,.11*M.C(Sine/wsVal))*CF.A(M.R(-18.5*M.C(Sine/wsVal)),0,M.R(2.5-5*M.C(Sine/(wsVal/2))) ),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
		elseif((State == 'Walk' or State == 'Run') and Mode == 10)then
			Change = 1
			local Alpha = .1
			RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11, 0.881578624+.5*M.C(Sine/32), -3.51015478e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271)*CF.A(M.R(-45),0,0),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.507622898, -0.617543876, -0.694063663, 0.999877989, -0.00717858272, 0.0138636231, -9.81731864e-05, 0.885106385, 0.465388477, -0.0156116197, -0.465333343, 0.884998262),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.499199599, -0.96504283, 0.0578122139, 0.999877989, -0.00369151891, 0.0151692061, -9.81731864e-05, 0.970136404, 0.242559701, -0.0156116197, -0.242531747, 0.970018268),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.2*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(M.R(-45),M.R(25),M.R(5+5*M.C(Sine/32))),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.2*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(M.R(-45),M.R(-25),M.R(-5-5*M.C(Sine/32))),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799)*CF.A(M.R(45),0,0),Alpha)
		elseif((State == 'Walk' or State == 'Run') and Mode == 666666666666)then
			Change = 1
			local Alpha = .1
			RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11, 1.61628103+.5*M.C(Sine/32), -3.51015478e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271)*CF.A(M.R(-65),0,0),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.507622898, -0.617543876, -0.694063663, 0.999877989, -0.00717858272, 0.0138636231, -9.81731864e-05, 0.885106385, 0.465388477, -0.0156116197, -0.465333343, 0.884998262),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.499199599, -0.96504283, 0.0578122139, 0.999877989, -0.00369151891, 0.0151692061, -9.81731864e-05, 0.970136404, 0.242559701, -0.0156116197, -0.242531747, 0.970018268),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.2*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(M.R(-55),M.R(25),M.R(5+5*M.C(Sine/32))),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.2*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(M.R(-55),M.R(-25),M.R(-5-5*M.C(Sine/32))),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799)*CF.A(M.R(65),0,0),Alpha)

		elseif((State == 'Walk' or State == 'Run'))then
			Change = 1
			local Alpha = .1
			RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11, 1.2571125+.5*M.C(Sine/32), -3.51015478e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271)*CF.A(M.R(-75),0,0),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.436587602, -0.992619872, 0.0206923336, 0.99808234, 0.0599006973, 0.0156119233, -0.0600048117, 0.998178363, 0.00628757617, -0.0152068557, -0.0072123101, 0.999858439),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.481217712, -0.504008591, -0.8678087, 0.997120202, -0.0733773932, -0.0191624481, 0.0741236135, 0.889526427, 0.450830936, -0.0160352942, -0.450953096, 0.892403722),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.2*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(M.R(-15),M.R(25),M.R(5+5*M.C(Sine/32))),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.2*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(M.R(-15),M.R(-25),M.R(-5-5*M.C(Sine/32))),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799)*CF.A(M.R(75),0,0),Alpha)

		elseif(State == 'Jump')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		elseif(State == 'Fall')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		elseif(State == 'Paralyzed')then
			-- paralyzed
		elseif(State == 'Sit')then
			-- sit
		end
	end



	for i,v in next, BloodPuddles do
		local mesh = i:FindFirstChild'CylinderMesh'
		BloodPuddles[i] = v + 1
		if(not mesh or i.Transparency >= 1)then
			i:destroy() 
			BloodPuddles[i] = nil
		elseif(v >= Frame_Speed*4)then
			local trans = (v-Frame_Speed*4)/(Frame_Speed*2)
			i.Transparency = trans
			if(mesh.Scale.Z > 0)then
				mesh.Scale = mesh.Scale-V3.N(.05,0,.05)
			end
		else
			i.Transparency = 0
		end
	end
end
end

local function floatingkiller()
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-gh 17375337078,17269952801,17269983359")
task.wait(4)
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-net")
local head = game.Players.LocalPlayer.Character["Accessory (EvilVoidHeadBackpack)"].Handle
local rightarm = game.Players.LocalPlayer.Character["Accessory (Right Void Wall)"].Handle
local leftarm = game.Players.LocalPlayer.Character["Accessory (Left Void Wall)"].Handle
local hrp = game.Players.LocalPlayer.Character["HumanoidRootPart"]
local droppos = hrp.CFrame * CFrame.new(0,6,-6)
head:BreakJoints()
rightarm:BreakJoints()
leftarm:BreakJoints()
head.CFrame = droppos
rightarm.CFrame = droppos
leftarm.CFrame = droppos
head.Anchored = true
rightarm.Anchored = true
leftarm.Anchored = true
task.wait(6)
head.Anchored = false
rightarm.Anchored = false
leftarm.Anchored = false
local attach0 = Instance.new("Attachment")
local attach1 = Instance.new("Attachment")
attach1.Name = "head"
local attach02 = Instance.new("Attachment")
local attach12 = Instance.new("Attachment")
attach12.Name = "rightarm"
local attach03 = Instance.new("Attachment")
local attach13 = Instance.new("Attachment")
attach13.Name = "leftarm"
local alignmove = Instance.new("AlignPosition")
local alignrotate = Instance.new("AlignOrientation")
local alignmove2 = Instance.new("AlignPosition")
local alignrotate2 = Instance.new("AlignOrientation")
local alignmove3 = Instance.new("AlignPosition")
local alignrotate3 = Instance.new("AlignOrientation")
attach0.Parent = head
attach1.Parent = hrp
attach1.CFrame = CFrame.new(0,10,6,-1,0,0,0,1,0,0,0,1)
alignmove.Parent = head
alignmove.MaxForce = math.huge
alignmove.Responsiveness = math.huge
alignmove.Attachment0 = attach0
alignmove.Attachment1 = attach1
alignrotate.Parent = head
alignrotate.MaxTorque = math.huge
alignrotate.Responsiveness = math.huge
alignrotate.Attachment0 = attach0
alignrotate.Attachment1 = attach1
attach02.Parent = rightarm
attach12.Parent = hrp
attach12.CFrame = CFrame.new(6,3,4,0,1,0,0,0,1,1,0,0)
alignmove2.Parent = rightarm
alignmove2.MaxForce = math.huge
alignmove2.Responsiveness = math.huge
alignmove2.Attachment0 = attach02
alignmove2.Attachment1 = attach12
alignrotate2.Parent = rightarm
alignrotate2.MaxTorque = math.huge
alignrotate2.Responsiveness = math.huge
alignrotate2.Attachment0 = attach02
alignrotate2.Attachment1 = attach12
attach03.Parent = leftarm
attach13.Parent = hrp
attach13.CFrame = CFrame.new(-6,3,4,0,1,0,0,0,1,1,0,0)
alignmove3.Parent = leftarm
alignmove3.MaxForce = math.huge
alignmove3.Responsiveness = math.huge
alignmove3.Attachment0 = attach03
alignmove3.Attachment1 = attach13
alignrotate3.Parent = leftarm
alignrotate3.MaxTorque = math.huge
alignrotate3.Responsiveness = math.huge
alignrotate3.Attachment0 = attach03
alignrotate3.Attachment1 = attach13
game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(bind)
	if bind == "z" then
		attach12.CFrame = CFrame.new(1,1,-4,0,1,0,0,0,1,1,0,0)
		attach13.CFrame = CFrame.new(-1,1,-4,0,1,0,0,0,1,1,0,0)
		task.wait(.2)
		attach12.CFrame = CFrame.new(1,-2,-4,0,1,0,0,0,1,1,0,0)
		attach13.CFrame = CFrame.new(-1,-2,-4,0,1,0,0,0,1,1,0,0)
		task.wait(.2)
		attach12.CFrame = CFrame.new(6,3,4,0,1,0,0,0,1,1,0,0)
		attach13.CFrame = CFrame.new(-6,3,4,0,1,0,0,0,1,1,0,0)
	end
end)
head.Parent = game.Workspace
rightarm.Parent = game.Workspace
leftarm.Parent = game.Workspace
spawn(function()
	while true do
		head.Velocity = Vector3.new(6400,0,6400)
		rightarm.Velocity = Vector3.new(6400,0,6400)
		leftarm.Velocity = Vector3.new(6400,0,6400)
		task.wait()
	end
end)
end

local function blackbanisher()
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-gh 117311153426168,116940095199813")
wait(4)
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-net")
local gun1 = game.Players.LocalPlayer.Character["Accessory (VoidRPG)"].Handle
local gun2 = game.Players.LocalPlayer.Character["Accessory (VoidAlligatorJaw)"].Handle
local hrp = game.Players.LocalPlayer.Character["HumanoidRootPart"]
local droppos = hrp.CFrame * CFrame.new(0,6,-6)
gun1:BreakJoints()
gun2:BreakJoints()
gun1.CFrame = droppos
gun2.CFrame = droppos
gun1.Anchored = true
gun2.Anchored = true
wait(6)
gun1.Anchored = false
gun2.Anchored = false
local attach0 = Instance.new("Attachment")
local attach1 = Instance.new("Attachment")
attach1.Name = "gun1"
local attach02 = Instance.new("Attachment")
local attach12 = Instance.new("Attachment")
attach12.Name = "gun2"
local alignmove = Instance.new("AlignPosition")
local alignrotate = Instance.new("AlignOrientation")
local alignmove2 = Instance.new("AlignPosition")
local alignrotate2 = Instance.new("AlignOrientation")
local tool = Instance.new("Tool")
local toolhandle = Instance.new("Part")
tool.Parent = game.Players.LocalPlayer.Backpack
tool.Name = "Black Banisher"
toolhandle.Name = "Handle"
toolhandle.Parent = tool
toolhandle.Transparency = 1
toolhandle.CanCollide = false
toolhandle.Massless = true
attach0.Parent = gun1
attach1.Parent = hrp
attach1.CFrame = CFrame.new(0,-20,0,1,0,0,0,1,0,0,0,1)
alignmove.Parent = gun1
alignmove.MaxForce = math.huge
alignmove.Responsiveness = math.huge
alignmove.Attachment0 = attach0
alignmove.Attachment1 = attach1
alignrotate.Parent = gun1
alignrotate.MaxTorque = math.huge
alignrotate.Responsiveness = math.huge
alignrotate.Attachment0 = attach0
alignrotate.Attachment1 = attach1
attach02.Parent = gun2
attach12.Parent = hrp
attach12.CFrame = CFrame.new(0,-20,0,1,0,0,0,1,0,0,0,1)
alignmove2.Parent = gun2
alignmove2.MaxForce = math.huge
alignmove2.Responsiveness = math.huge
alignmove2.Attachment0 = attach02
alignmove2.Attachment1 = attach12
alignrotate2.Parent = gun2
alignrotate2.MaxTorque = math.huge
alignrotate2.Responsiveness = math.huge
alignrotate2.Attachment0 = attach02
alignrotate2.Attachment1 = attach12
tool.Equipped:Connect(function()
	attach1.Parent = toolhandle
	attach12.Parent = toolhandle
	attach1.CFrame = CFrame.new(0,1,1.5,0,0,1,0,1,-0,-1,0,0)
	attach12.CFrame = CFrame.new(0,1.22000003,-3.79999995,0,0,1,0,1,-0,-1,0,0)
end)

tool.Unequipped:Connect(function()
	attach1.Parent = hrp
	attach12.Parent = hrp
	attach1.CFrame = CFrame.new(0,-20,0,1,0,0,0,1,0,0,0,1)
	attach12.CFrame = CFrame.new(0,-20,0,1,0,0,0,1,0,0,0,1)
end)
gun1.Parent = game.Workspace
gun2.Parent = game.Workspace
spawn(function()
	while true do
		gun1.Velocity = Vector3.new(6400,0,6400)
		gun2.Velocity = Vector3.new(6400,0,6400)
		task.wait()
	end
end)
end

local function semibot()
local blacklist = {"Pal Hair";"Kate Hair"}
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-gh 63690008,62724852")
wait(4)
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-net")
local torso1 = game.Players.LocalPlayer.Character["Pal Hair"].Handle
local torso2 = game.Players.LocalPlayer.Character["Kate Hair"].Handle
local hrp = game.Players.LocalPlayer.Character["HumanoidRootPart"]
local droppos = hrp.CFrame * CFrame.new(0,6,-6)
torso1.Mesh:Destroy()
torso2.Mesh:Destroy()
torso1:BreakJoints()
torso2:BreakJoints()
torso1.CFrame = droppos
torso2.CFrame = droppos
torso1.Anchored = true
torso2.Anchored = true
wait(6)
torso1.Anchored = false
torso2.Anchored = false
game.Players.LocalPlayer.Character.Archivable = true
local fakechar = game.Players.LocalPlayer.Character:Clone()
fakechar.Parent = game.Workspace
for i,v in pairs(fakechar:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end
fakechar["Head"].face:Destroy()
game.Players.LocalPlayer.Character.Parent = fakechar
local realchar = fakechar[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
for i,v in pairs(realchar:GetDescendants()) do if v:IsA("Accessory") then if table.find(blacklist,v.Name) then print("didn't break joints lol") else v.Handle:BreakJoints() end end end
realchar["Right Arm"]:BreakJoints()
realchar["Left Arm"]:BreakJoints()
realchar["Right Leg"]:BreakJoints()
realchar["Left Leg"]:BreakJoints()
fakechar.Animate.Disabled = true
fakechar.Animate.Enabled = true
spawn(function()
	while true do
		realchar["Right Arm"].CFrame = fakechar["Right Arm"].CFrame
		realchar["Right Arm"].Velocity = Vector3.new(6400,0,6400)
		realchar["Left Arm"].CFrame = fakechar["Left Arm"].CFrame
		realchar["Left Arm"].Velocity = Vector3.new(6400,0,6400)
		realchar["Right Leg"].CFrame = fakechar["Right Leg"].CFrame
		realchar["Right Leg"].Velocity = Vector3.new(6400,0,6400)
		realchar["Left Leg"].CFrame = fakechar["Left Leg"].CFrame
		realchar["Left Leg"].Velocity = Vector3.new(6400,0,6400)
		torso1.CFrame = fakechar["Torso"].CFrame * CFrame.new(0.5,0,0) * CFrame.Angles(1.57,0,0)
		torso1.Velocity = Vector3.new(6400,0,6400)
		torso2.CFrame = fakechar["Torso"].CFrame * CFrame.new(-0.5,0,0) * CFrame.Angles(1.57,0,0)
		torso2.Velocity = Vector3.new(6400,0,6400)
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(blacklist,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(blacklist,v.Name) then continue else v.Handle.Velocity = Vector3.new(6400,0,6400) end end end
		realchar["HumanoidRootPart"].CFrame = fakechar["HumanoidRootPart"].CFrame * CFrame.new(0,-20,0)
		realchar["HumanoidRootPart"].Velocity = Vector3.new(6400,0,6400)
		task.wait()
	end
end)
end

local function sinsemi()
local uselesstogglelol = false
local blacklist = {"Pal Hair";"Kate Hair";"Accessory (Right Void Wall)";"Accessory (Left Void Wall)"}
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-gh 63690008,62724852,17269952801,17269983359")
wait(4)
game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("-net")
local torso1 = game.Players.LocalPlayer.Character["Pal Hair"].Handle
local torso2 = game.Players.LocalPlayer.Character["Kate Hair"].Handle
local sindragonrightarm = game.Players.LocalPlayer.Character["Accessory (Right Void Wall)"].Handle
local sindragonleftarm = game.Players.LocalPlayer.Character["Accessory (Left Void Wall)"].Handle
local hrp = game.Players.LocalPlayer.Character["HumanoidRootPart"]
local droppos = hrp.CFrame * CFrame.new(0,6,-6)
torso1.Mesh:Destroy()
torso2.Mesh:Destroy()
torso1:BreakJoints()
torso2:BreakJoints()
sindragonrightarm:BreakJoints()
sindragonleftarm:BreakJoints()
torso1.CFrame = droppos
torso2.CFrame = droppos
sindragonrightarm.CFrame = droppos
sindragonleftarm.CFrame = droppos
torso1.Anchored = true
torso2.Anchored = true
sindragonrightarm.Anchored = true
sindragonleftarm.Anchored = true
wait(6)
torso1.Anchored = false
torso2.Anchored = false
sindragonrightarm.Anchored = false
sindragonleftarm.Anchored = false
game.Players.LocalPlayer.Character.Archivable = true
local fakechar = game.Players.LocalPlayer.Character:Clone()
fakechar.Parent = game.Workspace
for i,v in pairs(fakechar:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
	end
end
fakechar["Head"].face:Destroy()
game.Players.LocalPlayer.Character.Parent = fakechar
local realchar = fakechar[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character = fakechar
game.Workspace.CurrentCamera.CameraSubject = fakechar
for i,v in pairs(realchar:GetDescendants()) do if v:IsA("Accessory") then if table.find(blacklist,v.Name) then print("didn't break joints lol") else v.Handle:BreakJoints() end end end
realchar["Right Arm"]:BreakJoints()
realchar["Left Arm"]:BreakJoints()
realchar["Right Leg"]:BreakJoints()
realchar["Left Leg"]:BreakJoints()
fakechar.Animate.Disabled = true
fakechar.Animate.Enabled = true
spawn(function()
	while true do
		realchar["Right Arm"].CFrame = fakechar["Right Arm"].CFrame
		realchar["Right Arm"].Velocity = Vector3.new(6400,0,6400)
		realchar["Left Arm"].CFrame = fakechar["Left Arm"].CFrame
		realchar["Left Arm"].Velocity = Vector3.new(6400,0,6400)
		realchar["Right Leg"].CFrame = fakechar["Right Leg"].CFrame
		realchar["Right Leg"].Velocity = Vector3.new(6400,0,6400)
		realchar["Left Leg"].CFrame = fakechar["Left Leg"].CFrame
		realchar["Left Leg"].Velocity = Vector3.new(6400,0,6400)
		torso1.CFrame = fakechar["Torso"].CFrame * CFrame.new(0.5,0,0) * CFrame.Angles(1.57,0,0)
		torso1.Velocity = Vector3.new(6400,0,6400)
		torso2.CFrame = fakechar["Torso"].CFrame * CFrame.new(-0.5,0,0) * CFrame.Angles(1.57,0,0)
		torso2.Velocity = Vector3.new(6400,0,6400)
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(blacklist,v.Name) then continue else v.Handle.CFrame = fakechar[v.Name].Handle.CFrame end end end
		for i,v in pairs(realchar:GetChildren()) do if v:IsA("Accessory") then if table.find(blacklist,v.Name) then continue else v.Handle.Velocity = Vector3.new(6400,0,6400) end end end
		if uselesstogglelol == false then
			realchar["HumanoidRootPart"].CFrame = fakechar["HumanoidRootPart"].CFrame * CFrame.new(0,-20,0)
		else
			realchar["HumanoidRootPart"].CFrame = fakechar["HumanoidRootPart"].CFrame * CFrame.new(0,0,-10)	
		end
		realchar["HumanoidRootPart"].Velocity = Vector3.new(6400,0,6400)
		task.wait()
	end
end)
game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
	uselesstogglelol = true
	wait(1)
	uselesstogglelol = false
end)
-----------------
--some sin thing--
--------------------------------------------------------------
--deivis97 edit--
--------------------------------------------------------------

Player=game:GetService("Players").LocalPlayer
Character=Player.Character 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character:FindFirstChildOfClass("Humanoid")
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
trispeed=1
pathtrans=.7
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
player=nil 
cloak=false
lightcolor='Royal purple'

local Color1=("Royal purple")

mouse=Player:GetMouse()
--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=BrickColor.new("Toothpaste")
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
player=Player 
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor 
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false 
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position 
NoOutline(fp)
fp.Material="Neon"
fp:BreakJoints()
return fp 
end
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh) 
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="rbxassetid://"..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end
 
function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end
 
local Color1=("Toothpaste")

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.015
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
  tf = tf + s
  if tf >= frame then
    if allowframeloss then
      script.Heartbeat:Fire()
      lastframe = tick()
    else
      for i = 1, math.floor(tf / frame) do
        script.Heartbeat:Fire()
      end
      lastframe = tick()
    end
    if tossremainder then
      tf = 0
    else
      tf = tf - frame * math.floor(tf / frame)
    end
  end
end)
function swait(num)
  if num == 0 or num == nil then
    ArtificialHB.Event:wait(0)
  else
    for i = 0, num do
      ArtificialHB.Event:wait(0)
    end
  end
end
 
 
function so(id,par,pit,vol)
  local sou = Instance.new("Sound", par or workspace)
  if par == Character then
    sou.Parent = Torso
  end
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "rbxassetid://" .. id
  sou.PlayOnRemove = true
  sou:Destroy()
end
 
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return workspace:FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://4770583",vt(0,0,0),vt(x1,y1,z1))
--rbxassetid://4770560
game:GetService("Debris"):AddItem(prt,2)
CF=prt.CFrame
coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
for i=0,1,0.2 do
swait()
Part.CFrame=CF*cf(0,0,-0.4)
end
for i=0,1,delay do
swait()
--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
Mesh.Scale=Mesh.Scale
end
for i=0,1,0.1 do
swait()
Part.Transparency=i
end
Part:Destroy()
end),prt,msh,CF)
end
 
function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame*euler(math.random(0,360),math.random(0,360),math.random(0,360))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh)
end
 
function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,cframe)
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
swait()
Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh,wld)
end
 
function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Material = "Neon"
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
swait()
Weld.C0=euler(i*20,0,0)
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh,wld)
end
 
function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(250,0,0))
prt.Material = "Neon"
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(250,0,0))
prt2.Anchored=true
prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
game:GetService("Debris"):AddItem(prt2,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,0.1 do
swait()
Part.CFrame=Part.CFrame*cf(0,0.5,0)
end
Part:Destroy()
end),prt2,msh2)
end
for i=0,1,delay*2 do
swait()
Part.CFrame=Part.CFrame
Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
end
Part:Destroy()
end),prt,msh)
end

function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh)
end
 
function MagicRing(brickcolor,cframe,x1,y1,z1,x2,y2,z2,x3,y3,z3)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*euler(x2,y2,z2)
--"rbxassetid://168892465"
local msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,0.03 do
swait()
Part.CFrame=Part.CFrame
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh)
end
 
function BreakEffect(brickcolor,cframe,x1,y1,z1)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
CF=Part.CFrame
Numbb=0
randnumb=math.random()/10
rand1=math.random()/10
for i=0,1,rand1 do
swait()
CF=CF*cf(0,math.random()/2,0)
--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
Part.CFrame=CF*euler(Numbb,0,0)
Part.Transparency=i
Numbb=Numbb+randnumb
end
Part:Destroy()
end),prt,CF,Numbb,randnumb)
end
 
function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://1051557",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame*euler(0,0.7,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh)
end
 
function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://20329976",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame*cf(0,y3/2,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh)
end
 
function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*cf(x,y,z)
msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
local num=math.random()
local num2=math.random(-3,2)+math.random()
local numm=0
for i=0,1,delay*2 do
swait()
Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
Part.Transparency=i
numm=numm+0.01
end
Part:Destroy()
Mesh:Destroy()
end),prt,msh,x,y,z)
end

function puncheff(par)
so(386946017,par,math.random(80,120)/100,1)
MagicCircle(BrickColor.new("Really red"), par.CFrame, 1, 1, 1, 1, 1, 1, 0.05)
end

Damagefunc=function(hit,efft,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
        if hit.Parent==nil then
                return
        end
         local torsy = (hit.Parent:findFirstChild("Torso") or hit.Parent:findFirstChild("UpperTorso"))
       h=hit.Parent:FindFirstChildOfClass("Humanoid")
        for _,v in pairs(hit.Parent:children()) do
        if v:IsA("Humanoid") then
        h=v
        end
        end
        if hit.Parent.Parent:FindFirstChild("Head")~=nil then
        h=hit.Parent.Parent:FindFirstChildOfClass("Humanoid")
        end
        if hit.Parent.className=="Hat" then
        hit=hit.Parent.Parent:findFirstChild("Head")
        end
        if h~=nil and hit.Parent.Name~=Character.Name and hit.Parent:FindFirstChild("Head")~=nil then
        if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
        --[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
                        return
                end]]
--                        hs(hit,1.2) 
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=game:service("Players").LocalPlayer
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                Damage=math.random(minim,maxim)
--                h:TakeDamage(Damage)
                blocked=false
                block=hit.Parent:findFirstChild("Block")
                if block~=nil then
                print(block.className)
                if block.className=="NumberValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock==nil then
                block.Value=block.Value-1
                end
                end
                end
                if block.className=="IntValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock~=nil then
                block.Value=block.Value-1
                end
                end
                end
                end
				if efft == "Blunt" then
				puncheff(hit)
				end
				h.MaxHealth = 30
                
                showDamage(hit.Parent,Damage,.5,TorsoColor)
                if Type=="Knockdown" then
                local hum=hit.Parent:FindFirstChildOfClass("Humanoid")
hum.PlatformStand=true
coroutine.resume(coroutine.create(function(HHumanoid)
swait(30)
HHumanoid.PlatformStand=false
end),hum)
local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=RootPart.CFrame.lookVector*knockback
bodvol.P=50000
bodvol.maxForce=Vector3.new(5000, 0, 5000) * 5000000000
bodvol.Parent=torsy
torsy.CFrame = CFrame.new(torsy.Position)*CFrame.Angles(math.rad(90),0,0)
game:GetService("Debris"):AddItem(bodvol,.5)
                elseif Type=="Normal" then
                vp=Instance.new("BodyVelocity")
                vp.P=500
                vp.maxForce=Vector3.new(math.huge,0,math.huge)
                vp.velocity=Character.Torso.CFrame.lookVector*knockback
--                if KnockbackType==1 then
--                vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05
--                elseif KnockbackType==2 then
--                vp.velocity=Property.CFrame.lookVector*knockback
--                end
                if knockback>0 then
                        vp.Parent=torsy
                end
                game:GetService("Debris"):AddItem(vp,.5)
                elseif Type=="Up" then
                local bodyVelocity=Instance.new("BodyVelocity")
                bodyVelocity.velocity=vt(0,10,0)
                bodyVelocity.P=1000
                bodyVelocity.maxForce=Vector3.new(1e+009, 1e+009, 1e+009)
                bodyVelocity.Parent=hit
                game:GetService("Debris"):AddItem(bodyVelocity,1)
                rl=Instance.new("BodyAngularVelocity")
                rl.P=3000
                rl.maxTorque=Vector3.new(500000,500000,500000)*50000000000000
                rl.angularvelocity=Vector3.new(math.random(-20,20),math.random(-20,20),math.random(-20,20))
                rl.Parent=hit
                game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Snare" then
                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=100
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=torsy.Position
                bp.Parent=torsy
                game:GetService("Debris"):AddItem(bp,1)
                elseif Type=="Target" then
                if Targetting==false then
                ZTarget=torsy
                coroutine.resume(coroutine.create(function(Part) 
                so("15666462",Part,1,1.5) 
                swait(5)
                so("15666462",Part,1,1.5) 
                end),ZTarget)
                TargHum=ZTarget.Parent:FindFirstChildOfClass("Humanoid")
                targetgui=Instance.new("BillboardGui")
                targetgui.Parent=ZTarget
                targetgui.Size=UDim2.new(10,100,10,100)
                targ=Instance.new("ImageLabel")
                targ.Parent=targetgui
                targ.BackgroundTransparency=1
                targ.Image="rbxassetid://4834067"
                targ.Size=UDim2.new(1,0,1,0)
                cam.CameraType="Scriptable"
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                Targetting=true
                RocketTarget=ZTarget
                for i=1,Property do
                --while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do
                if Humanoid.Health>0 and Character.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then
                swait()
                end
                --workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)
                end
                Targetting=false
                RocketTarget=nil
                targetgui:Destroy()
                cam.CameraType="Custom"
                end
                end
                        debounce=Instance.new("BoolValue")
                        debounce.Name="DebounceHit"
                        debounce.Parent=hit.Parent
                        debounce.Value=true
                        game:GetService("Debris"):AddItem(debounce,Delay)
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=Player
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                CRIT=false
                hitDeb=true
                AttackPos=6
        end
end
 
function showDamage(Dude, Text, Time, Color)
coroutine.resume(coroutine.create(function()
local naeeym2 = Instance.new("BillboardGui",Dude)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = Dude.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = Text
tecks2.Font = "Fantasy"
tecks2.TextSize = 24
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(.8,0,0)
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
swait(10)
for i = 0,1,.05 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(0,0,.005,0)
tecks2.TextStrokeTransparency = i
tecks2.TextTransparency = i
end
naeeym2:Destroy()
end))
end

    Player=game:GetService('Players').LocalPlayer
    Character=Player.Character
    Mouse=Player:GetMouse()
    m=Instance.new('Model',Character)


    local function weldBetween(a, b)
        local weldd = Instance.new("ManualWeld")
        weldd.Part0 = a
        weldd.Part1 = b
        weldd.C0 = CFrame.new()
        weldd.C1 = b.CFrame:inverse() * a.CFrame
        weldd.Parent = a
        return weldd
    end
    
    it=Instance.new
    
    function nooutline(part)
        part.TopSurface,part.BottomSurface,part.LeftSurface,part.RightSurface,part.FrontSurface,part.BackSurface = 10,10,10,10,10,10
    end
    
    function parta(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)
        local fp=it("Part")
        fp.formFactor=formfactor
        fp.Parent=parent
        fp.Reflectance=reflectance
        fp.Transparency=transparency
        fp.CanCollide=false
        fp.Locked=true
        fp.BrickColor=BrickColor.new(tostring(brickcolor))
        fp.Name=name
        fp.Size=size
        fp.Position=Character.Torso.Position
        nooutline(fp)
        fp.Material=material
        fp:BreakJoints()
        return fp
    end
    
    function mesh(Mesh,part,meshtype,meshid,offset,scale)
        local mesh=it(Mesh)
        mesh.Parent=part
        if Mesh=="SpecialMesh" then
            mesh.MeshType=meshtype
            mesh.MeshId=meshid
        end
        mesh.Offset=offset
        mesh.Scale=scale
        return mesh
    end
    
    function weld(parent,part0,part1,c0,c1)
        local weld=it("Weld")
        weld.Parent=parent
        weld.Part0=part0
        weld.Part1=part1
        weld.C0=c0
        weld.C1=c1
        return weld
    end

local modelzorz=Instance.new("Model") 
modelzorz.Parent=Character 
modelzorz.Name="Claw1"

Handle=parta(Enum.FormFactor.Custom,modelzorz,Enum.Material.Neon,0,1,TorsoColor,"Handle",Vector3.new(4,4,1))
spawn(function()
	while true do
		fakechar["Claw1"].Gear.Transparency = 1
		sindragonrightarm.CFrame = fakechar["Claw1"].Gear.CFrame * CFrame.Angles(0,0,1.57)
		sindragonrightarm.Velocity = Vector3.new(6400,0,6400)
		task.wait()
	end
end)
Handleweld=weld(m,Character["Torso"],Handle,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-6.74455023, 0.843135834, 3.31332064, 0.866820872, 0.000393055088, -0.498619556, 0.129048944, -0.966104209, 0.223582461, -0.481630623, -0.258152217, -0.837489963))
Gear=parta(Enum.FormFactor.Custom,modelzorz,Enum.Material.SmoothPlastic,0,1,"Really black","Part",Vector3.new(4.29999971, 4.30000019, 1))
Gearweld=weld(modelzorz,Handle,Gear,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0552597046, -0.0398271084, -0.0363032818, 0.999988854, -3.23429704e-005, 0.00164097548, 3.37436795e-005, 0.999994695, -0.000689953566, -0.00164103508, 0.000689953566, 0.999993086))

local modelzorz2=Instance.new("Model") 
modelzorz2.Parent=Character 
modelzorz2.Name="Claw2"

Handle2=parta(Enum.FormFactor.Custom,modelzorz2,Enum.Material.Neon,0,1,TorsoColor,"Handle",Vector3.new(4,4,1))
spawn(function()
	while true do
		fakechar["Claw2"].Gear2.Transparency = 1
		sindragonleftarm.CFrame = fakechar["Claw2"].Gear2.CFrame * CFrame.Angles(0,0,1.57)
		sindragonleftarm.Velocity = Vector3.new(6400,0,6400)
		task.wait()
	end
end)
Handle2weld=weld(modelzorz2,Character["Torso"],Handle2,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(6.65693045, 1.66835713, 2.9684639, 0.866025746, 0.129405379, 0.482963592, -3.67555799e-006, -0.965926409, 0.258817136, 0.499999553, -0.224144042, -0.836516559))
Gear2=parta(Enum.FormFactor.Custom,modelzorz2,Enum.Material.SmoothPlastic,0,1,"Really black","Part",Vector3.new(4.29999971, 4.30000019, 1))
Gear2weld=weld(modelzorz2,Handle2,Gear2,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.049841404, 0.049908638, 2.78949738e-005, 0.999990344, -5.01424074e-006, -1.49011612e-007, 5.28991222e-006, 0.999994934, 2.98023224e-008, 2.38418579e-007, -1.63912773e-007, 0.999994636))

local modelzorz3=Instance.new("Model") 
modelzorz3.Parent=Character 
modelzorz3.Name="Eye"

handle=parta(Enum.FormFactor.Custom,modelzorz3,Enum.Material.SmoothPlastic,0,1,TorsoColor,"Handle",Vector3.new(1,6,6))
handleweld=weld(modelzorz3,Character["Torso"],handle,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.22326851, -3.5562191, -0.038143158, 0, 0, 1, 0, 1, 0, -1, 0, 0))

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
	
Gear2 = New("Part",modelzorz2,"Gear2",{BrickColor = BrickColor.new("Really black"),Size = Vector3.new(5, 7, 5),CFrame = CFrame.new(68.5, 2.5, -42.5, 0, 0, -1, -1, 0, 0, 0, 1, 0),CanCollide = false,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",Gear2,"Mesh",{Offset = Vector3.new(0, 0, -1),Scale = Vector3.new(25, 25, 25),MeshId = "rbxassetid://92052865",MeshType = Enum.MeshType.FileMesh,})
Weld = New("ManualWeld",Gear2,"Weld",{Part0 = Gear2,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0, -1, 0, 0, 0, 1, -1, 0, 0),C1 = CFrame.new(0, 3.57627869e-06, 2.99999237, 0.999991357, -6.94066244e-08, 4.63798642e-07, 6.63525327e-07, -0.999994934, -2.62497252e-07, 2.04890966e-08, 2.84217094e-13, -0.999997139),})
Gear = New("Part",modelzorz,"Gear",{BrickColor = BrickColor.new("Really black"),Size = Vector3.new(5, 7, 5),CFrame = CFrame.new(78.5, 2.5, -42.5, 0, 0, 1, 1, 0, 0, 0, 1, 0),CanCollide = false,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",Gear,"Mesh",{Offset = Vector3.new(0, 0, -1),Scale = Vector3.new(25, 25, 25),MeshId = "rbxassetid://92053026",MeshType = Enum.MeshType.FileMesh,})
Weld = New("ManualWeld",Gear,"Weld",{Part0 = Gear,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),C1 = CFrame.new(0, 3.57627869e-06, 2.99999237, 0.999991357, -6.94066244e-08, 4.63798642e-07, 6.63525327e-07, -0.999994934, -2.62497252e-07, 2.04890966e-08, 2.84217094e-13, -0.999997139),})
DragonHead = New("Part",modelzorz3,"DragonHead",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(72.5999985, 5.5999999, -63.5999985, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",DragonHead,"Mesh",{Scale = Vector3.new(5, 5, 5),MeshId = "rbxassetid://420164161",MeshType = Enum.MeshType.FileMesh,})
Weld = New("ManualWeld",DragonHead,"Weld",{Part0 = DragonHead,Part1 = handle,C1 = CFrame.new(-4, 0, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0),})
EyePart = New("Part",modelzorz3,"EyePart",{BrickColor = BrickColor.new("Really red"),Material = Enum.Material.Neon,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(70.0999985, 8.60000038, -63.5999985, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.384314, 0.145098, 0.819608),})
Mesh = New("SpecialMesh",EyePart,"Mesh",{Scale = Vector3.new(1, 1, 2),MeshId = "rbxassetid://420164161",MeshType = Enum.MeshType.Sphere,})
Weld = New("ManualWeld",EyePart,"Weld",{Part0 = EyePart,Part1 = handle,C1 = CFrame.new(-4, 3.00000048, 2.5, 0, 0, 1, 0, 1, 0, -1, -0, -0),})
EyePart = New("Part",modelzorz3,"EyePart",{BrickColor = BrickColor.new("Really red"),Material = Enum.Material.Neon,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(75.0999985, 8.60000038, -63.5999985, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.384314, 0.145098, 0.819608),})
Mesh = New("SpecialMesh",EyePart,"Mesh",{Scale = Vector3.new(1, 1, 2),MeshId = "rbxassetid://420164161",MeshType = Enum.MeshType.Sphere,})
Weld = New("ManualWeld",EyePart,"Weld",{Part0 = EyePart,Part1 = handle,C1 = CFrame.new(-4, 3.00000048, -2.5, 0, 0, 1, 0, 1, 0, -1, -0, -0),})
EyePart = New("Part",modelzorz3,"EyePart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(70.0999985, 8.60000038, -64.0999985, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",EyePart,"Mesh",{Scale = Vector3.new(0.899999976, 0.899999976, 0.5),MeshId = "rbxassetid://420164161",MeshType = Enum.MeshType.Sphere,})
Weld = New("ManualWeld",EyePart,"Weld",{Part0 = EyePart,Part1 = handle,C1 = CFrame.new(-4.5, 3.00000048, 2.5, 0, 0, 1, 0, 1, 0, -1, -0, -0),})
EyePart = New("Part",modelzorz3,"EyePart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(75.0999985, 8.60000038, -64.0999985, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",EyePart,"Mesh",{Scale = Vector3.new(0.899999976, 0.899999976, 0.5),MeshId = "rbxassetid://420164161",MeshType = Enum.MeshType.Sphere,})
Weld = New("ManualWeld",EyePart,"Weld",{Part0 = EyePart,Part1 = handle,C1 = CFrame.new(-4.5, 3.00000048, -2.5, 0, 0, 1, 0, 1, 0, -1, -0, -0),})


local moosick = it("Sound",Character)
moosick.SoundId = "rbxassetid://1268378545"
 --142653441, 175067863
moosick.Name = "moosick"
moosick.Looped = true
moosick.Volume = 1

anim = Character:findFirstChild("Animate")
if anim then
anim:Destroy()
end

local pemit = Instance.new("ParticleEmitter")
pemit.Color = ColorSequence.new(Color3.new(.2,5,5))
pemit.Lifetime = NumberRange.new(1)
pemit.Acceleration = Vector3.new(0,20,0)
pemit.EmissionDirection = "Front"
pemit.Size = NumberSequence.new(1,0)
pemit.Speed = NumberRange.new(10)
pemit.LightEmission = 1
pemit.Rate = 500
pemit.Rotation = NumberRange.new(0,360)
pemit.RotSpeed = NumberRange.new(150)
pemit.Texture = "rbxasset://textures/particles/smoke_main.dds"
pemit.Enabled = false

local pe1 = pemit:Clone()
pe1.Parent = Handle
local pe2 = pemit:Clone()
pe2.Parent = Handle2
local pe3 = pemit:Clone()
pe3.Parent = handle
pe3.EmissionDirection = "Right"
pe3.Rate = 1000

local light = Instance.new("PointLight", Character.Torso)
light.Color = TorsoColor.Color
light.Brightness = 5
light.Range = 15
light.Enabled = false

local Footsteps = it("Sound",Character.Torso)
Footsteps.SoundId = "rbxassetid://142665235"
Footsteps.Looped = true
Footsteps.Pitch = 0.8
Footsteps.Volume = 0.3

local Footsteps2 = it("Sound",Character.Torso)
Footsteps2.SoundId = "rbxassetid://142665235"
Footsteps2.Looped = true
Footsteps2.Pitch = 1
Footsteps2.Volume = 0.4

function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Material = Enum.Material.Neon
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part:Destroy()
end),prt,msh)
end

TrailDeb = false

function equipanim()
attack=true
Gear.Transparency = 1
Gear2.Transparency = 1
for i,v in pairs(modelzorz3:children()) do
if v:IsA("BasePart") then v.Transparency = 1 end
end
Humanoid.WalkSpeed = 0
moosick:Play()
for i=0,1,0.05 do
swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4,0,0)*angles(math.rad(0),math.rad(-30),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,0,0)*angles(math.rad(0),math.rad(30),math.rad(0)),.2)
end
swait(60)
for i=0,1,0.05 do
swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.2,0.5,.5)*euler(-30,0,-20),.3)
RW.C0=clerp(RW.C0,cf(1.2,0.5,.5)*euler(-30,0,20),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(50),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4,0,0)*angles(math.rad(0),math.rad(-30),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,0,0)*angles(math.rad(0),math.rad(30),math.rad(0)),.2)
end
so(136007472,Torso,1,1)
swait(30)
for i=0,30 do
swait(1)
MagicRing(BrickColor.new("Really red"), Gear.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), 20, 20, 2, 1, 1, 1, -1, -1, 0)
MagicRing(BrickColor.new("Really red"), Gear2.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), 20, 20, 2, 1, 1, 1, -1, -1, 0)
MagicRing(BrickColor.new("Really red"), DragonHead.CFrame*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50))), 60, 60, 6, 1, 1, 1, -3, -3, 0)
end
swait(180)
so(233096557,Torso,1,5)
so(233091205,Torso,1,5)
so(150829983,DragonHead,.9,5)
MagicCircle(BrickColor.new("Really red"), Gear.CFrame, 10, 10, 10, 1, 1, 1, 0.01)
MagicCircle(BrickColor.new("Really red"), Gear2.CFrame, 10, 10, 10, 1, 1, 1, 0.01)
MagicCircle(BrickColor.new("Really red"), DragonHead.CFrame, 20, 20, 20, 1, 1, 1, 0.01)
Gear.Transparency = 0
Gear2.Transparency = 0
for i,v in pairs(modelzorz3:children()) do
if v:IsA("BasePart") and v ~= handle then v.Transparency = 0 end
end
pe1.Enabled = true
pe2.Enabled = true
pe3.Enabled = true
light.Enabled = true
for a=1,300 do
handleweld.C0 = cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(50),math.rad(0),math.rad(0))
swait()
end
attack = false
end

function attackone()
attack=true
if TrailDeb == false then
TrailDeb = true
end
coroutine.wrap(function()
local Old = Handle.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
    con1=Gear.Touched:connect(function(hit) Damagefunc(hit,"Blunt",20,25,20,"Normal",RootPart,.2,1) end) 
    for i=0,1,0.08 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-5),math.rad(0),math.rad(-10)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(10)),.3)
        RW.C0=clerp(RW.C0,cf(1,0.5,-0.5)*euler(.5,1.8,1.5),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(-3,1,2)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
    end
    so("231917758",Handle,1,.9) 
    so("159972643",Torso,1,1) 
    for i=0,1,0.1 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(20)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(-20)),.3)
        RW.C0=clerp(RW.C0,cf(1.5,0.5,-0.5)*euler(80,1.8,1.5),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(-4,1,-8)*angles(math.rad(-85),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
    end
    --dmgstop()
    attack=false
    con1:disconnect()
if TrailDeb == true then
TrailDeb = false
end
end

function attacktwo()
attack=true
if TrailDeb == false then
TrailDeb = true
end
coroutine.wrap(function()
local Old = Handle2.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle2.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
    con1=Gear2.Touched:connect(function(hit) Damagefunc(hit,"Blunt",20,25,20,"Normal",RootPart,.2,1) end) 
    for i=0,1,0.08 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(20)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(-20)),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-30,0,-20),.3)
        RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-2),math.rad(-25),math.rad(15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(-5,1,-5)*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
    end
    so("231917758",Handle2,1,.8) 
    so("159972627",Torso,1,1) 
    for i=0,1,0.1 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-20)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(20)),.3)
        LW.C0=clerp(LW.C0,cf(-1,0.5,-1)*euler(-30,0,20),.3)
        RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-2),math.rad(-25),math.rad(15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(10,1,-5)*angles(math.rad(0),math.rad(-80),math.rad(20)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
    end
    --dmgstop()
    attack=false
    con1:disconnect()
if TrailDeb == true then
TrailDeb = false
end
end

function attackthree()
attack=true
if TrailDeb == false then
TrailDeb = true
end						
coroutine.wrap(function()
local Old = Handle.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
    con1=Gear.Touched:connect(function(hit) Damagefunc(hit,"Blunt",20,25,30,"Up",RootPart,.2,1) end) 
    for i=0,1,0.08 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*euler(0,0,0),.2)
        RW.C0=clerp(RW.C0,cf(1,0.5,-0.5)*euler(0.5,-1.3,-0.1),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(3,7,-1)*angles(math.rad(20),math.rad(0),math.rad(-120)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
    end
    so("231917758",Handle,1,1) 
    so("159882477",Torso,1,1) 
    for i=0,1,0.05 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(2,4,-3)*angles(math.rad(120),math.rad(0),math.rad(-120)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
        RW.C0=clerp(RW.C0,cf(1.5,0.5,-0.5)*euler(2,-1.3,0.1),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
    end
    --dmgstop()
    attack=false
    con1:disconnect()
if TrailDeb == true then
TrailDeb = false
end
end

function attackfour()
attack=true
if TrailDeb == false then
TrailDeb = true
end
coroutine.wrap(function()
local Old = Handle2.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle2.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
coroutine.wrap(function()
local Old = Handle.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
    con1=Gear2.Touched:connect(function(hit) Damagefunc(hit,"Blunt",10,20,math.random(20,40),"Normal",RootPart,.2,1) end) 
    con2=Gear.Touched:connect(function(hit) Damagefunc(hit,"Blunt",10,20,math.random(20,40),"Normal",RootPart,.2,1) end) 
    for i=0,1,0.08 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1)*angles(math.rad(40),math.rad(0),math.rad(-40)),.3)
        RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-40),math.rad(0),math.rad(40)),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(70),math.rad(0),math.rad(-45)),.3)
       	RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*angles(math.rad(0),math.rad(0),math.rad(-20)),.3)
		LH.C0=clerp(LH.C0,cf(-1,0.5,0)*euler(0,-1.57,0)*angles(math.rad(-10),math.rad(30),math.rad(-40)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(1.5,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)  
        Handle2weld.C0=clerp(Handle2weld.C0,cf(-1.5,3,0)*angles(math.rad(0),math.rad(180),math.rad(180)),.2)  
    end
if anim then
anim.Disabled=true
end
    so("231917758",Torso,1,0.7) 
    so("159882584",Torso,1,1) 
    for i=0,1,0.04 do
        swait()
        Torso.Velocity=RootPart.CFrame.lookVector*50
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1)*angles(math.rad(-5),math.rad(0),math.rad(0+360*i)),.3)
        RW.C0=clerp(RW.C0,cf(1.2,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
        LW.C0=clerp(LW.C0,cf(-1.2,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
        RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(3,4,0)*angles(math.rad(0),math.rad(0),math.rad(90)),.2)  
        Handle2weld.C0=clerp(Handle2weld.C0,cf(-3,4,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.2) 
    end
    --dmgstop()
    attack=false
    con1:disconnect()
    con2:disconnect()
if anim then
anim.Disabled=false
end
if TrailDeb == true then
TrailDeb = false
end
end

function BlastEffect(brickcolor, cframe, x1, y1, z1, x2, y2, z2)
	local prt = parta(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = mesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", vt(0, 0, 0), vt(x1, y1, z1))
	coroutine.resume(coroutine.create(function() 
		for i = 0, 1, 0.05 do
			swait()
			prt.Transparency = i
			msh.Scale = msh.Scale + vt(x2, y2, z2)
		end
		prt.Parent = nil
	end))
end

function MagniDamage(par,efft,magni,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
  for _, c in pairs(workspace:GetDescendants()) do
    local hum = c:FindFirstChildOfClass("Humanoid")
    if hum ~= nil and c:FindFirstChild("IsTeamMateOfCK")==nil then
      local head = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
      if head ~= nil then
        local targ = head.Position - par.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head,efft,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
        end
      end
    end
  end
end

function MagicCircle4(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = part(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 2)
	coroutine.resume(coroutine.create(function(Part, Mesh) 
		for i = 0, 1, delay do
			swait()
			Part.CFrame = Part.CFrame
			Part.Transparency = i
			Mesh.Scale = Mesh.Scale + vt(x3, y3, z3)
		end
		Part.Parent = nil
	end), prt, msh)
end

function smashdown()
attack=true

if TrailDeb == false then
TrailDeb = true
end
coroutine.wrap(function()
local Old = Handle2.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle2.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
coroutine.wrap(function()
local Old = Handle.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
    con1=Gear2.Touched:connect(function(hit) Damagefunc(hit,"Blunt",10,15,100,"Normal",RootPart,.2,1) end) 
    con2=Gear.Touched:connect(function(hit) Damagefunc(hit,"Blunt",10,15,100,"Normal",RootPart,.2,1) end) 
    for i=0,1,0.08 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
		Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
		LW.C0=clerp(LW.C0,cf(-1.5,1,0)*euler(math.rad(180),0,0),.3)
		RW.C0=clerp(RW.C0,cf(1.5,1,0)*euler(math.rad(180),0,0),.3)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(50),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(4,30,10)*angles(math.rad(35),math.rad(0),math.rad(-90)),.2)  
        Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,30,10)*angles(math.rad(35),math.rad(0),math.rad(90)),.2)  
    end
	Humanoid.WalkSpeed = 0
    so("231917758",Torso,1,0.7) 
    so("159882584",Torso,1,1) 
	    for i=0,1,0.08 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
		Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(math.rad(90),0,0),.3)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(math.rad(90),0,0),.3)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-10),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(4,6,-10)*angles(math.rad(-35),math.rad(0),math.rad(-90)),.2)  
        Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,6,-10)*angles(math.rad(-35),math.rad(0),math.rad(90)),.2)  
	end
	con1:disconnect()
    con2:disconnect()
    attack=false
if anim then
anim.Disabled=false
end
if TrailDeb == true then
TrailDeb = false
end
	local ref = it("Part",Character)
	ref.Size = Vector3.new(0,0,0)
	ref.Anchored = true
	ref.CanCollide = false
	ref.Transparency = 1
	local looky = RootPart.CFrame
	for i=1,10 do
	ref.CFrame = looky*CFrame.new(0,-2.5,-10*i)
	BlastEffect(BrickColor.new("Really red"),ref.CFrame,1,.2,1,1,0,1)
	BlastEffect(BrickColor.new("Really red"),ref.CFrame,5,1,.5,.1,2,.1)
	MagniDamage(ref,"",10,30,35,50,"Knockdown",RootPart,.2,1)
	so(178452221,ref,.6,1)
    so(192410084,ref,1,1)
	swait(5)
	end
	ref:Destroy()
	swait(60)
    --dmgstop()
end

function mudads()
attack=true
so("616593932",Torso,1,3)
print("SUNLIGHT YELLO OVRDREV")


if TrailDeb == false then
TrailDeb = true
end
coroutine.wrap(function()
local Old = Handle2.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle2.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
coroutine.wrap(function()
local Old = Handle.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
    con1=Gear2.Touched:connect(function(hit) Damagefunc(hit,"Blunt",10,15,10,"Normal",RootPart,.05,1) end) 
    con2=Gear.Touched:connect(function(hit) Damagefunc(hit,"Blunt",10,15,10,"Normal",RootPart,.05,1) end) 
	Humanoid.WalkSpeed = 16
    so("159882584",Torso,1,1) 
	    for i=0,1,0.08 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
		Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
		LW.C0=clerp(LW.C0,cf(-1.2,1,0)*euler(math.rad(90),math.rad(-90),0),.3)
		RW.C0=clerp(RW.C0,cf(1.2,1,0)*euler(math.rad(90),math.rad(90),0),.3)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(4,2,10)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)  
        Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,2,10)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)  
		end
		for a = 1,20 do
		so("231917758",Torso,math.random(6,10)/10,1) 
	    for i=0,1,0.2 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
		Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
		LW.C0=clerp(LW.C0,cf(-1.2,1,-2)*euler(math.rad(90),math.rad(-90),0),.3)
		RW.C0=clerp(RW.C0,cf(1.2,1,2)*euler(math.rad(90),math.rad(90),0),.3)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(math.random(-10,10),math.random(0,4),-20)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)  
        Handle2weld.C0=clerp(Handle2weld.C0,cf(math.random(-10,10),math.random(0,4),20)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)  
		end
		so("231917758",Torso,math.random(6,10)/10,1) 
	    for i=0,1,0.2 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
		Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
		LW.C0=clerp(LW.C0,cf(-1.2,1,2)*euler(math.rad(90),math.rad(-90),0),.3)
		RW.C0=clerp(RW.C0,cf(1.2,1,-2)*euler(math.rad(90),math.rad(90),0),.3)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(math.random(-10,10),math.random(0,4),20)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)  
        Handle2weld.C0=clerp(Handle2weld.C0,cf(math.random(-10,10),math.random(0,4),-20)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)  
		end
		end
	con1:disconnect()
    con2:disconnect()
    --dmgstop()
    attack=false
if anim then
anim.Disabled=false
end
if TrailDeb == true then
TrailDeb = false
end
end

function laser()
attack = true
Humanoid.WalkSpeed = 16
for i=0,1,0.05 do
swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.2,0.5,.5)*euler(-30,0,-20),.3)
RW.C0=clerp(RW.C0,cf(1.2,0.5,.5)*euler(-30,0,20),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(50),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4,0,0)*angles(math.rad(0),math.rad(-30),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,0,0)*angles(math.rad(0),math.rad(30),math.rad(0)),.2)
end
	local blmod = Instance.new("Model",Character)
	  for a = 1, 5 do
	  	local blast2 = it("Part",blmod)
		blast2.Size = vt(1,1,1)
		blast2.BrickColor = TorsoColor
		blast2.Material = "Neon"
        blast2.Anchored = false
		blast2.CanCollide = false
		local blwe = Instance.new("Weld",blast2)
		blwe.Part0 = DragonHead
		blwe.Part1 = blast2		
		blwe.C0 = CFrame.new(0, 0, -5)
		blwe.C1 = CFrame.fromEulerAnglesXYZ(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        local m = Instance.new("BlockMesh", blast2)
        m.Scale = Vector3.new(6,6,6)
        coroutine.resume(coroutine.create(function()
          for i = 0,1,.1 do
            blast2.Transparency = 1.2-i
            swait()
            blwe.C1 = blwe.C1 * CFrame.fromEulerAnglesXYZ(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
          end
		while blast2 do
		swait()
		blwe.C1 = blwe.C1 * CFrame.fromEulerAnglesXYZ(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
		end
      	end))
	  end
so(864314263,DragonHead,1,5)
for i=1,150 do
MagicRing(BrickColor.new("Really red"), DragonHead.CFrame * CFrame.new(0,0,-5) * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), 20, 20, 2, 1, 1, 1, -1, -1, 0)
handleweld.C0 = cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(50),math.rad(0),math.rad(0))
swait()
end
for i=0,1,0.05 do
swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.2,0.5,.5)*euler(-30,0,-20),.3)
RW.C0=clerp(RW.C0,cf(1.2,0.5,.5)*euler(-30,0,20),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
handleweld.C0=clerp(handleweld.C0,cf(math.random(-1,1),math.random(5,7),math.random(6,8))*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4,0,0)*angles(math.rad(0),math.rad(-30),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,0,0)*angles(math.rad(0),math.rad(30),math.rad(0)),.2)
end
		so(162246701,DragonHead,1,5)
		local frontcf = DragonHead.CFrame * CFrame.new(0,0,-5)
		local sannd = Instance.new("Sound",Torso)
		sannd.SoundId = "rbxassetid://162246683"
		sannd.Looped = true
		sannd.Volume = 1
		sannd:Play()
		local hitcf = mouse.Hit
		local ref = it("Part",Character)
		ref.Size = Vector3.new(0,0,0)
		ref.Anchored = true
		ref.CanCollide = false
		ref.Transparency = 1
		local blast = it("Part",blmod)
		blast.Size = vt(1,1,(frontcf.p - hitcf.p).magnitude)
		blast.BrickColor = TorsoColor
		blast.Material = "Neon"
        blast.Anchored = true
		blast.CanCollide = false
		blast.CFrame = CFrame.new((frontcf.p + hitcf.p)/2,frontcf.p)
		local m = Instance.new("BlockMesh", blast)
        m.Scale = Vector3.new(5,5,1)
		for a = 1, 200 do
		local frontcf = DragonHead.CFrame * CFrame.new(0,0,-5)
		local hitcf = mouse.Hit
		ref.CFrame = hitcf
		blast.Size = vt(1,1,(frontcf.p - hitcf.p).magnitude)
		blast.CFrame = CFrame.new((frontcf.p + hitcf.p)/2,frontcf.p)
		MagicBlock(TorsoColor, hitcf, 1, 1, 1, 6, 6, 6, 0.1)
		MagniDamage(ref,"",10,5,7,0,"Knockdown",RootPart,.05,1)
		handleweld.C0 = cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(-5),math.rad(0),math.rad(0))
		--handleweld.C0 = cf(math.random(-2,2),math.random(4,8),math.random(5,9))*angles(math.rad(-5),math.rad(0),math.rad(0))
		swait(1)
		end
		for a = 0,1,.05 do
		sannd.Volume = a
		for _, b in pairs(blmod:GetChildren()) do
		b.Transparency = a
		end
		swait()
		end
		sannd:Destroy()
		blmod:Destroy()
		attack = false
end

function yummy()
attack=true
if TrailDeb == false then
TrailDeb = true
end
coroutine.wrap(function()
local Old = Handle.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
local grab
local torsy
local ghum
local soaa
    for i=0,1,0.05 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-5),math.rad(0),math.rad(-10)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(10)),.3)
        RW.C0=clerp(RW.C0,cf(1,0.5,-0.5)*euler(.5,1.8,1.5),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(-3,1,2)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
    end
con1=Gear.Touched:connect(function(hit)
if grab == nil and hit.Parent ~= Character then
torsy = (hit.Parent:findFirstChild("Torso") or hit.Parent:findFirstChild("UpperTorso"))
ghum = hit.Parent:FindFirstChildOfClass("Humanoid")
if ghum ~= nil and torsy ~= nil then
grab=hit.Parent
so(386946017,hit,1,1)
local soaa = it("Sound",grab.Head)
soaa.Volume = 1
local cho = math.random(1,5)
if cho == 1 then
soaa.SoundId = "rbxassetid://111896685"
elseif cho == 2 then
soaa.SoundId = "rbxassetid://535528169"
elseif cho == 3 then
soaa.SoundId = "rbxassetid://1080363252"
elseif cho == 4 then
soaa.SoundId = "rbxassetid://147758746"
elseif cho == 5 then
soaa.SoundId = "rbxassetid://626777433"
soaa.Volume = .2
soaa.TimePosition = 1
end
soaa:Play()
end
end
end) 
    so("231917758",Handle,1,.9) 
    so("159972643",Torso,1,1) 
    for i=0,3,0.1 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(20)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(-20)),.3)
        RW.C0=clerp(RW.C0,cf(1.5,0.5,-0.5)*euler(80,1.8,1.5),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(-4,1,-8)*angles(math.rad(-85),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
if grab ~= nil then
	Humanoid.WalkSpeed = 0
	con1:disconnect()
    for i=0,3,0.05 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(20),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(2,20,-8)*angles(math.rad(0),math.rad(0),math.rad(-90)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
    for i=0,1,0.1 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(20),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(0,16,5)*angles(math.rad(0),math.rad(0),math.rad(-90)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
	grab:BreakJoints()
	for i,v in pairs(grab:children()) do
	if v:IsA("BasePart") then
	game:service'Debris':AddItem(v,.01)
	end
	end
	local ref = it("Part",Character)
	ref.Size = Vector3.new(0,0,0)
	ref.Anchored = true
	ref.CanCollide = false
	ref.Transparency = 1
	ref.CFrame = Gear.CFrame
so(206082327,Gear,1,3)
local partasdeff = Instance.new("ParticleEmitter",ref)
partasdeff.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
partasdeff.LightEmission = .1
partasdeff.Size = NumberSequence.new(0.2)
partasdeff.Texture = "rbxassetid://771221224"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.2),NumberSequenceKeypoint.new(1, 5)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
partasdeff.Transparency = bbb
partasdeff.Size = aaa
partasdeff.ZOffset = .9
partasdeff.Acceleration = Vector3.new(0, -5, 0)
partasdeff.LockedToPart = false
partasdeff.EmissionDirection = "Back"
partasdeff.Lifetime = NumberRange.new(1, 2)
partasdeff.Rate = 1000
partasdeff.Rotation = NumberRange.new(-100, 100)
partasdeff.RotSpeed = NumberRange.new(-100, 100)
partasdeff.Speed = NumberRange.new(6)
partasdeff.VelocitySpread = 10000
partasdeff.Enabled=false
partasdeff:Emit(70)
game:service'Debris':AddItem(ref,5)
swait(90)
so(2767085,DragonHead,1,1)
	swait(150)
	    for i=0,1,0.1 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(4,0,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
	    end
so(133966572,DragonHead,.8,2)
for i=1,15 do
for a=1,5 do
handleweld.C0 = cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(-20),math.rad(0),math.rad(0))
swait()
end
local bo = it("Part",Character)
bo.Size = vt(.2,.6,1)
bo.BrickColor = BrickColor.new("Yellow")
bo.CFrame = DragonHead.CFrame*CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
bo.Velocity = RootPart.CFrame.lookVector*40
local m = it("SpecialMesh",bo)
m.MeshId = "rbxassetid://521754610"
m.TextureId = "rbxassetid://521754612"
m.Scale = vt(math.random(9,13)/10,math.random(9,13)/10,math.random(9,13)/10)
coroutine.wrap(function()
swait(300)
for a=0,1,.05 do
swait()
bo.Transparency = a
end
bo:Destroy()
end)()
end
for a=1,5 do
handleweld.C0 = cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(-20),math.rad(0),math.rad(0))
swait()
end
local bo = it("Part",Character)
bo.Size = vt(1,1,1)
bo.BrickColor = BrickColor.new("Yellow")
bo.CFrame = DragonHead.CFrame*CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
bo.Velocity = RootPart.CFrame.lookVector*40
local m = it("SpecialMesh",bo)
m.MeshId = "rbxassetid://521754610"
m.TextureId = "rbxassetid://521754612"
m.Scale = vt(1,1,1)
local bonus = Instance.new("Sound",Character)
bonus.Name = "bonus"
bonus.SoundId = "rbxassetid://199607491"
bonus.Looped = false
bonus.Volume = 2
bonus:Play()
coroutine.wrap(function()
swait(300)
for a=0,1,.05 do
swait()
bo.Transparency = a
end
bo:Destroy()
end)()
swait(60)
end
    --dmgstop()
    attack=false
    con1:disconnect()
if TrailDeb == true then
TrailDeb = false
end
end

function smek()
attack=true
if TrailDeb == false then
TrailDeb = true
end
coroutine.wrap(function()
local Old = Handle.CFrame.p
while true do swait()
if not TrailDeb then break end
local New = Handle.CFrame.p
local Mag =(Old -New).magnitude
local Dis =(Old +New)/2
local Trail = Instance.new("Part",Character)
Trail.Material = "Neon"
Trail.Anchored = true
Trail.CanCollide = false
Trail.BrickColor = TorsoColor
Trail.Size = Vector3.new(0.2,Mag,0.2)
Trail.TopSurface = 0
Trail.BottomSurface = 0
Trail.formFactor = "Custom"
Trail.CFrame = CFrame.new(Dis,New)* CFrame.Angles(math.pi/2,0,0)
local ms = Instance.new("BlockMesh",Trail)
ms.Scale = Vector3.new(1,1,1)
local TM = Instance.new("CylinderMesh",Trail)
TM.Scale = Vector3.new(20,1,20)
Old = New
coroutine.wrap(function()
for i = 1,0,-0.1 do
swait()
TM.Scale = TM.Scale * Vector3.new(i,1,i)
end
Trail:remove()
end)()
coroutine.wrap(function()
for i = 1,10 do
swait()
Trail.Transparency = Trail.Transparency +0.1
end end)()end end)()
local grab
local torsy
local ghum
local soaa
    for i=0,1,0.05 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-5),math.rad(0),math.rad(-10)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(10)),.3)
        RW.C0=clerp(RW.C0,cf(1,0.5,-0.5)*euler(.5,1.8,1.5),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(-3,1,2)*angles(math.rad(90),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
    end
con1=Gear.Touched:connect(function(hit)
if grab == nil and hit.Parent ~= Character then
torsy = (hit.Parent:findFirstChild("Torso") or hit.Parent:findFirstChild("UpperTorso"))
ghum = hit.Parent:FindFirstChildOfClass("Humanoid")
if ghum ~= nil and torsy ~= nil then
grab=hit.Parent
so(386946017,hit,1,1)
soaa = it("Sound",grab.Head)
soaa.Volume = 1
local cho = math.random(1,5)
if cho == 1 then
soaa.SoundId = "rbxassetid://111896685"
elseif cho == 2 then
soaa.SoundId = "rbxassetid://535528169"
elseif cho == 3 then
soaa.SoundId = "rbxassetid://1080363252"
elseif cho == 4 then
soaa.SoundId = "rbxassetid://147758746"
elseif cho == 5 then
soaa.SoundId = "rbxassetid://626777433"
soaa.Volume = .2
soaa.TimePosition = 1
end
game:service'Debris':AddItem(soaa,8)
soaa:Play()
end
end
end) 
    so("231917758",Handle,1,.9) 
    so("159972643",Torso,1,1) 
    for i=0,3,0.1 do
        swait()
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(20)),.3)
        Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(-20)),.3)
        RW.C0=clerp(RW.C0,cf(1.5,0.5,-0.5)*euler(80,1.8,1.5),.3)
        LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(2),math.rad(25),math.rad(-15)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(-4,1,-10)*angles(math.rad(-85),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
if grab ~= nil then
	Humanoid.WalkSpeed = 0
	con1:disconnect()
    for i=0,3,0.05 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-10),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(2,20,-8)*angles(math.rad(0),math.rad(0),math.rad(-90)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
for a=1,5 do
    for i=0,1,0.1 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-10),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(2,-5,-8)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
so(386946017,torsy,1,1)
BlastEffect(BrickColor.new("Really red"),CFrame.new(torsy.Position),.5,.5,.5,.5,.2,.5)
if ghum.Health > 10 then
Damagefunc(torsy,"",8,10,0,"Normal",RootPart,0,1)
end
    for i=0,1,0.1 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-10),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(2,20,-8)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
end
for i=1,30 do
swait()
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
end
    for i=0,5,0.1 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(2,15,10)*angles(math.rad(0),math.rad(180),math.rad(180)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
    for i=0,1,0.1 do
        swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(-4)),.3)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,-0.2)*angles(math.rad(20),math.rad(0),math.rad(4)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
		handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-10),math.rad(0),math.rad(0)),.2)
        Handleweld.C0=clerp(Handleweld.C0,cf(2,20,-20)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
        Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
		if torsy~=nil then
		ghum.PlatformStand = true
		torsy.CFrame = Gear.CFrame
		end
    end
torsy.Velocity = RootPart.CFrame.lookVector*100
coroutine.wrap(function()
local par,pos
repeat swait() par,pos = rayCast(torsy.Position,Vector3.new(0,-1,0),2,grab) until par
Damagefunc(torsy,"",15,20,0,"Normal",RootPart,0,1)
BlastEffect(BrickColor.new("Really red"),CFrame.new(pos),0,0,0,.5,.2,.5)
so(260430079,torsy,1,5)
swait(60)
ghum.PlatformStand = false
end)()
swait(60)
end
    --dmgstop()
    attack=false
    con1:disconnect()
if TrailDeb == true then
TrailDeb = false
end
end

function rawr()
attack=true
Humanoid.WalkSpeed = 0
for i=0,1,0.05 do
swait()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.2,0.5,.5)*euler(-30,0,-20),.3)
RW.C0=clerp(RW.C0,cf(1.2,0.5,.5)*euler(-30,0,20),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.3)
handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(50),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4,0,0)*angles(math.rad(0),math.rad(-30),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,0,0)*angles(math.rad(0),math.rad(30),math.rad(0)),.2)
end
so(150829983,DragonHead,.9,5)
for a=1,300 do
handleweld.C0 = cf(math.random(-5,5)/10,math.random(55,65)/10,math.random(65,75)/10)*angles(math.rad(50),math.rad(0),math.rad(0))
BlastEffect(BrickColor.new("Really red"),RootPart.CFrame*CFrame.new(0,-2,0)*CFrame.Angles(0,math.random(-50,50),0),1,.2,1,2,0,2)
MagniDamage(Torso,"",30,1,1,5,"Knockdown",RootPart,.05,1)
swait()
end
attack = false
end

equipanim()

mouse.Button1Down:connect(function()
        if attack==false and attacktype==1 then
                attacktype=2
                attackone()
        elseif attack==false and attacktype==2 then
                attacktype=3
                attacktwo()
		elseif attack==false and attacktype==3 then
				attacktype=1
				attackthree()
        end
end)

mouse.KeyDown:connect(function(k)
k = k:lower()
if k=='m' then
if Character:FindFirstChild("moosick")~=nil then
if moosick.IsPlaying == true then
moosick:Stop()
elseif moosick.IsPaused == true then
moosick:Play()
end
elseif Character:FindFirstChild("moosick")==nil then
local moosick = Instance.new("Sound",Character)
moosick.Name = "moosick"
moosick.SoundId = "rbxassetid://608726256"
moosick.Looped = true
moosick.Volume = 1
moosick:Play()
end
end
if attack == false then
if k=='z' then
mudads()
elseif k=='x' then
smashdown()
elseif k=='c' then
laser()
elseif k=='v' then
smek()
elseif k=='b' then
yummy()
elseif k=='g' then
rawr()
end
end
end)

local sine = 0
local change = 1
local val = 0

local mananum=0
while true do
swait()
sine = sine + change
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if equipped==true or equipped==false then
--if Anim=="Idle" and attack==false then
--idle=idle+1
--else
--idle=0
--end
if idle>=1000 then
if attack==false then
--Sheath()
end
end
if RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then
Footsteps:Stop()
Footsteps2:Stop()
Neck.C0=clerp(Neck.C0,necko*euler(-0.2,0,0),.3)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.25,0,0.5),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.25,0,-0.5),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,0,-.75)*euler(-0.5,1.57,0)*euler(0,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,-.3)*euler(-0.5,-1.57,0)*euler(0,0,0),.2)
handleweld.C0=clerp(handleweld.C0,cf(0-1*math.cos(sine/40),6-0.5*math.cos(sine/20),7)*angles(math.rad(-5+5*math.cos(sine/20)),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(0,0,0)*angles(math.rad(20),math.rad(20),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(20),math.rad(-20),math.rad(0)),.2)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then
Footsteps:Stop()
Footsteps2:Stop()
Neck.C0=clerp(Neck.C0,necko*euler(0.3,0,0),.3)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*euler(0,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(0.1,0,1),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(0.1,0,-1),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0.6,1.57,0)*euler(0,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(-0.8,-1.57,0)*euler(0,0,0),.2)
handleweld.C0=clerp(handleweld.C0,cf(0-1*math.cos(sine/40),6-0.5*math.cos(sine/20),7)*angles(math.rad(-5+5*math.cos(sine/20)),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4,-1,0)*angles(math.rad(-20),math.rad(-10),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4,-1,0)*angles(math.rad(-20),math.rad(10),math.rad(0)),.2)
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
change=0.5
if attack==false then
Footsteps:Stop()
Footsteps2:Stop()
Humanoid.WalkSpeed=12
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(6),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*angles(math.rad(3+3*math.cos(sine/36)),math.rad(0),math.rad(0)),.3)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(16-6*math.cos(sine/28))),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-16+6*math.cos(sine/28))),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(16)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(24)),.3)
handleweld.C0=clerp(handleweld.C0,cf(0-1*math.cos(sine/40),6-0.5*math.cos(sine/20),7)*angles(math.rad(-5+5*math.cos(sine/20)),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4-1*math.cos(sine/30),0,0-1*math.cos(sine/30))*angles(math.rad(0+8*math.cos(sine/30)),math.rad(0),math.rad(0-8*math.cos(sine/30))),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4+1*math.cos(sine/36),0,0+1*math.cos(sine/36))*angles(math.rad(0-12*math.cos(sine/36)),math.rad(0),math.rad(0-12*math.cos(sine/36))),.2)
end
elseif torvel>2 and hitfloor~=nil then
Anim="Walk"
if attack==false then
change=1
--[[RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(35),math.rad(0),math.rad(15*math.cos(sine/10))),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-135*math.cos(sine/9)),math.rad(0),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(135*math.cos(sine/9)),math.rad(0),math.rad(0)),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0)),.3)
--Handleweld.C0=clerp(--Handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*euler(0,0,0),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0.1,0,0),.2)
--RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-0.1,0,0.2),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-5),math.rad(-25),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(5),math.rad(25),math.rad(-20)),.3)
RH.C0=clerp(RH.C0,RHC0,.3)
LH.C0=clerp(LH.C0,LHC0,.3)
Handleweld.C0=clerp(Handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.2)
]]--
Humanoid.WalkSpeed=50
--Footsteps:Play()
--Footsteps2:Stop()
--RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0+0.1*math.cos(sine/2.5))*angles(math.rad(10+1*math.cos(sine/2.5)),math.rad(0),math.rad(1-5*math.cos(sine/5))),.3)
--Neck.C0=clerp(Neck.C0,necko*euler(0+0.075*math.cos(sine/2.5),0,0)*angles(math.rad(0),math.rad(0),math.rad(1+5*math.cos(sine/5))),.3)
--Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.3)
--RW.C0=clerp(RW.C0,cf(1.4+0.25*math.cos(sine/5),0.5+0.25*math.cos(sine/5),-0.2+0.5*math.cos(sine/5))*angles(math.rad(20-60*math.cos(sine/5)),math.rad(0),math.rad(-4+30*math.cos(sine/5))),.3)
--LW.C0=clerp(LW.C0,cf(-1.4+0.25*math.cos(sine/5),0.5-0.25*math.cos(sine/5),-0.2-0.5*math.cos(sine/5))*angles(math.rad(20+60*math.cos(sine/5)),math.rad(0),math.rad(4+30*math.cos(sine/5))),.3)
--RH.C0=clerp(RH.C0,cf(1,-1-0.1*math.cos(sine/5),0-0.25*math.cos(sine/5))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0+50*math.cos(sine/5))),.3)
--LH.C0=clerp(LH.C0,cf(-1,-1+0.1*math.cos(sine/5),0+0.25*math.cos(sine/5))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0+50*math.cos(sine/5))),.3)
--handleweld.C0=clerp(handleweld.C0,cf(0-1*math.cos(sine/40),6-0.5*math.cos(sine/20),7)*angles(math.rad(-5+5*math.cos(sine/20)),math.rad(0),math.rad(0)),.2)
--Handleweld.C0=clerp(Handleweld.C0,cf(4-.5*math.cos(sine/30),0,0-.5*math.cos(sine/30))*angles(math.rad(0+1*math.cos(sine/30)),math.rad(-30),math.rad(0-1*math.cos(sine/30))),.2)
--Handle2weld.C0=clerp(Handle2weld.C0,cf(-4+.5*math.cos(sine/36),0,0+.5*math.cos(sine/36))*angles(math.rad(0-3*math.cos(sine/36)),math.rad(30),math.rad(0-3*math.cos(sine/36))),.2)
--end
--elseif torvel>=22 and hitfloor~=nil then
--Anim="Run"
change=1
--if attack==false then
Footsteps:Stop()
Footsteps2:Play()
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0+0.1*math.cos(sine/2.5))*angles(math.rad(20+1*math.cos(sine/2.5)),math.rad(0),math.rad(0)),.3)
Neck.C0=clerp(Neck.C0,necko*euler(-0.2+0.075*math.cos(sine/2.5),0,0),.3)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-40),math.rad(0),math.rad(24)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-40),math.rad(0),math.rad(-24)),.3)
RH.C0=clerp(RH.C0,cf(1,-1-0.1*math.cos(sine/5),0-0.5*math.cos(sine/5))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0+70*math.cos(sine/5))),.3)
LH.C0=clerp(LH.C0,cf(-1,-1+0.1*math.cos(sine/5),0+0.5*math.cos(sine/5))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0+70*math.cos(sine/5))),.3)
handleweld.C0=clerp(handleweld.C0,cf(0,6,7)*angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
Handleweld.C0=clerp(Handleweld.C0,cf(4-.5*math.cos(sine/30),0,0-.5*math.cos(sine/30))*angles(math.rad(0+1*math.cos(sine/30)),math.rad(-60),math.rad(0-1*math.cos(sine/30))),.2)
Handle2weld.C0=clerp(Handle2weld.C0,cf(-4+.5*math.cos(sine/36),0,0+.5*math.cos(sine/36))*angles(math.rad(0-3*math.cos(sine/36)),math.rad(60),math.rad(0-3*math.cos(sine/36))),.2)
end
end
end
end
end

local main = Arrayfield:CreateWindow({
	Name = "Meow Hub";
	LoadingTitle = "Meow Hub";
	LoadingSubtitle = "By ImaMeow @Rcb424";
	KeySystem = true;
	KeySettings = {
		Title = "Meow Hub";
		Subtitle = "Meow Hub Key System";
		Note = "Join https://dsc.gg/jabb and type meow?meowhub!";
		FileName = "MeowHubKey";
		SaveKey = false;
		GrabKeyFromSite = false;
		Key = "{B1D4E236-0561-4CBD-91EF-4C1D786B9DD5}"
	}
})

local maintab = main:CreateTab("Hat Scripts",14843436332)
maintab:CreateSection("Hat Scripts",true)
maintab:CreateButton({
	Name = "Doll (Discontinued)";
	Callback = function()
		fuckdoll()
	end;
})
maintab:CreateButton({
	Name = "Floating Killer";
	Callback = function()
		floatingkiller()
	end;
})
maintab:CreateButton({
	Name = "Black Banisher";
	Callback = function()
		blackbanisher()
	end;
})
maintab:CreateSection("Reanimate Scripts",true)
maintab:CreateButton({
	Name = "Meowz Reanimate";
	Callback = function()
		meowz()
	end;
})
maintab:CreateButton({
	Name = "Animation Man (Meowz)";
	Callback = function()
		animationmeowz()
	end;
})
maintab:CreateButton({
	Name = "Sniper (Meowz)";
	Callback = function()
		snipermeowz()
	end;
})
maintab:CreateButton({
	Name = "Star Glitcher (Meowz)";
	Callback = function()
		starmeowz()
	end;
})
maintab:CreateButton({
	Name = "Semi-Bot";
	Callback = function()
		semibot()
	end;
})
maintab:CreateButton({
	Name = "Sin Dragon (Semi-Bot)";
	Callback = function()
		sinsemi()
	end;
})
maintab:CreateSection("Backdoor",true)
maintab:CreateInput({
	Name = "Kill Player (Segway Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		for i,v in pairs(game:GetDescendants()) do
			if v.Name == "DestroySegway" then
				v:FireServer(game.Workspace[text].Head,{Value = game.Workspace[text].Head})
			end
		end
	end
})
maintab:CreateInput({
	Name = "Kill Player (Car Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		game.ReplicatedStorage.DeleteCar:FireServer(game.Workspace[text].Head)
	end
})
maintab:CreateInput({
	Name = "Kick Player (Segway Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		for i,v in pairs(game:GetDescendants()) do
			if v.Name == "DestroySegway" then
				v:FireServer(game.Players[text],{Value = game.Players[text]})
			end
		end
	end
})
maintab:CreateInput({
	Name = "Kick Player (Car Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		game.ReplicatedStorage.DeleteCar:FireServer(game.Players[text])
	end
})
maintab:CreateInput({
	Name = "Block Head Player (Segway Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		for i,v in pairs(game:GetDescendants()) do
			if v.Name == "DestroySegway" then
				v:FireServer(game.Workspace[text].Head.Mesh,{Value = game.Workspace[text].Head.Mesh})
			end
		end
	end
})
maintab:CreateInput({
	Name = "Block Head Player (Car Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		game.ReplicatedStorage.DeleteCar:FireServer(game.Workspace[text].Head.Mesh)
	end
})
maintab:CreateInput({
	Name = "Remove Limbs Player (Segway Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		for i,v in pairs(game:GetDescendants()) do
			if v.Name == "DestroySegway" then
				v:FireServer(game.Workspace[text]["Right Arm"],{Value = game.Workspace[text]["Right Arm"]})
				v:FireServer(game.Workspace[text]["Left Arm"],{Value = game.Workspace[text]["Left Arm"]})
				v:FireServer(game.Workspace[text]["Right Leg"],{Value = game.Workspace[text]["Right Leg"]})
				v:FireServer(game.Workspace[text]["Left Leg"],{Value = game.Workspace[text]["Left Leg"]})
			end
		end
	end
})
maintab:CreateInput({
	Name = "Remove Limbs Player (Car Method)";
	PlaceholderText = "Player Name";
	NumbersOnly = false;
	CharacterLimit = 20;
	OnEnter = true;
	RemoveTextAfterFocusLost = true;
	Callback = function(text)
		game.ReplicatedStorage.DeleteCar:FireServer(game.Workspace[text]["Right Arm"])
		game.ReplicatedStorage.DeleteCar:FireServer(game.Workspace[text]["Left Arm"])
		game.ReplicatedStorage.DeleteCar:FireServer(game.Workspace[text]["Right Leg"])
		game.ReplicatedStorage.DeleteCar:FireServer(game.Workspace[text]["Left Leg"])
	end
})
maintab:CreateButton({
	Name = "Delete Tool (Segway Method)";
	Callback = function()
		local destroytool = Instance.new("Tool")
		destroytool.Name = "Destroy Tool"
		destroytool.Parent = game.Players.LocalPlayer.Backpack
		destroytool.RequiresHandle = false
		destroytool.Activated:Connect(function()
			for i,v in pairs(game:GetDescendants()) do
				if v.Name == "DestroySegway" then
					v:FireServer(game.Players.LocalPlayer:GetMouse().Target,{Value = game.Players.LocalPlayer:GetMouse().Target})
				end
			end
		end)
	end
})
maintab:CreateButton({
	Name = "Delete Tool (Car Method)";
	Callback = function()
		local destroytool = Instance.new("Tool")
		destroytool.Name = "Destroy Tool"
		destroytool.Parent = game.Players.LocalPlayer.Backpack
		destroytool.RequiresHandle = false
		destroytool.Activated:Connect(function()
			game.ReplicatedStorage.DeleteCar:FireServer(game.Players.LocalPlayer:GetMouse().Target)
		end)
	end
})
maintab:CreateSection("For Developers",true)
maintab:CreateButton({
	Name = "Set Random GUID To Clipboard";
	Callback = function()
		setclipboard(game:GetService("HttpService"):GenerateGUID(true))
	end
})
